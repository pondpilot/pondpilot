{
    "any_value": {
      "syntax": "any_value(arg)",
      "description": "Returns the first non-null value from `arg`. This function is [affected by ordering](#order-by-clause-in-aggregate-functions)."
    },
    "arbitrary": {
      "syntax": "arbitrary(arg)",
      "description": "Returns the first value (null or non-null) from `arg`. This function is [affected by ordering](#order-by-clause-in-aggregate-functions)."
    },
    "arg_max": {
      "syntax": "arg_max(arg, val, n)",
      "description": "The generalized case of [`arg_max`](#arg_maxarg-val) for `n` values: returns a `LIST` containing the `arg` expressions for the top `n` rows ordered by `val` descending. This function is [affected by ordering](#order-by-clause-in-aggregate-functions)."
    },
    "arg_max_null": {
      "syntax": "arg_max_null(arg, val)",
      "description": "Finds the row with the maximum `val` and calculates the `arg` expression at that row. Rows where the `val` expression evaluates to `NULL` are ignored. This function is [affected by ordering](#order-by-clause-in-aggregate-functions)."
    },
    "arg_min": {
      "syntax": "arg_min(arg, val, n)",
      "description": "Returns a `LIST` containing the `arg` expressions for the \"bottom\" `n` rows ordered by `val` ascending. This function is [affected by ordering](#order-by-clause-in-aggregate-functions)."
    },
    "arg_min_null": {
      "syntax": "arg_min_null(arg, val)",
      "description": "Finds the row with the minimum `val` and calculates the `arg` expression at that row. Rows where the `val` expression evaluates to `NULL` are ignored. This function is [affected by ordering](#order-by-clause-in-aggregate-functions)."
    },
    "array_agg": {
      "syntax": "array_agg(arg)",
      "description": "Returns a `LIST` containing all the values of a column. This function is [affected by ordering](#order-by-clause-in-aggregate-functions)."
    },
    "avg": {
      "syntax": "avg(arg)",
      "description": "Calculates the average of all non-null values in `arg`."
    },
    "bit_and": {
      "syntax": "bit_and(arg)",
      "description": "Returns the bitwise AND operation performed on all bitstrings in a given expression."
    },
    "bit_or": {
      "syntax": "bit_or(arg)",
      "description": "Returns the bitwise OR operation performed on all bitstrings in a given expression."
    },
    "bit_xor": {
      "syntax": "bit_xor(arg)",
      "description": "Returns the bitwise XOR operation performed on all bitstrings in a given expression."
    },
    "bitstring_agg": {
      "syntax": "bitstring_agg(arg, min, max)",
      "description": "Returns a bitstring with bits set for each distinct position defined in `arg`. All positions must be within the range [`min`, `max`] or an `Out of Range Error` will be thrown."
    },
    "bool_and": {
      "syntax": "bool_and(arg)",
      "description": "Returns `true` if every input value is `true`, otherwise `false`."
    },
    "bool_or": {
      "syntax": "bool_or(arg)",
      "description": "Returns `true` if any input value is `true`, otherwise `false`."
    },
    "count": {
      "syntax": "count(arg)",
      "description": "Returns the number of non-null values in `arg`."
    },
    "favg": {
      "syntax": "favg(arg)",
      "description": "Calculates the average using a more accurate floating point summation (Kahan Sum)."
    },
    "first": {
      "syntax": "first(arg)",
      "description": "Returns the first value (null or non-null) from `arg`. This function is [affected by ordering](#order-by-clause-in-aggregate-functions)."
    },
    "fsum": {
      "syntax": "fsum(arg)",
      "description": "Calculates the sum using a more accurate floating point summation (Kahan Sum)."
    },
    "geomean": {
      "syntax": "geomean(arg)",
      "description": "Calculates the geometric mean of all non-null values in `arg`."
    },
    "histogram": {
      "syntax": "histogram(arg, boundaries)",
      "description": "Returns a `MAP` of key-value pairs representing the provided upper `boundaries` and counts of elements in the corresponding left-open and right-closed partition of the datatype. A boundary at the largest value of the datatype is automatically added when elements larger than all provided `boundaries` appear, see [`is_histogram_other_bin`]({% link docs/sql/functions/utility.md %}#is_histogram_other_binarg). Boundaries may be provided, e.g., via [`equi_width_bins`]({% link docs/sql/functions/utility.md %}#equi_width_binsminmaxbincountnice)."
    },
    "histogram_exact": {
      "syntax": "histogram_exact(arg, elements)",
      "description": "Returns a `MAP` of key-value pairs representing the requested elements and their counts. A catch-all element specific to the data-type is automatically added to count other elements when they appear, see [`is_histogram_other_bin`]({% link docs/sql/functions/utility.md %}#is_histogram_other_binarg)."
    },
    "last": {
      "syntax": "last(arg)",
      "description": "Returns the last value of a column. This function is [affected by ordering](#order-by-clause-in-aggregate-functions)."
    },
    "list": {
      "syntax": "list(arg)",
      "description": "Returns a `LIST` containing all the values of a column. This function is [affected by ordering](#order-by-clause-in-aggregate-functions)."
    },
    "max": {
      "syntax": "max(arg, n)",
      "description": "Returns a `LIST` containing the `arg` values for the \"top\" `n` rows ordered by `arg` descending."
    },
    "max_by": {
      "syntax": "max_by(arg, val, n)",
      "description": "Returns a `LIST` containing the `arg` expressions for the \"top\" `n` rows ordered by `val` descending."
    },
    "min": {
      "syntax": "min(arg, n)",
      "description": "Returns a `LIST` containing the `arg` values for the \"bottom\" `n` rows ordered by `arg` ascending."
    },
    "min_by": {
      "syntax": "min_by(arg, val, n)",
      "description": "Returns a `LIST` containing the `arg` expressions for the \"bottom\" `n` rows ordered by `val` ascending."
    },
    "product": {
      "syntax": "product(arg)",
      "description": "Calculates the product of all non-null values in `arg`."
    },
    "string_agg": {
      "syntax": "string_agg(arg, sep)",
      "description": "Concatenates the column string values with a separator. This function is [affected by ordering](#order-by-clause-in-aggregate-functions)."
    },
    "sum": {
      "syntax": "sum(arg)",
      "description": "Calculates the sum of all non-null values in `arg` / counts `true` values when `arg` is boolean."
    },
    "weighted_avg": {
      "syntax": "weighted_avg(arg, weight)",
      "description": "Calculates the weighted average all non-null values in `arg`, where each value is scaled by its corresponding `weight`. If `weight` is `NULL`, the corresponding `arg` value will be skipped."
    },
    "approx_count_distinct": {
      "syntax": "approx_count_distinct(x)",
      "description": "Gives the approximate count of distinct elements using HyperLogLog."
    },
    "approx_quantile": {
      "syntax": "approx_quantile(x, pos)",
      "description": "Gives the approximate quantile using T-Digest."
    },
    "reservoir_quantile": {
      "syntax": "reservoir_quantile(x, quantile, sample_size = 8192)",
      "description": "Gives the approximate quantile using reservoir sampling, the sample size is optional and uses 8192 as a default size."
    },
    "corr": {
      "syntax": "corr(y, x)",
      "description": "The correlation coefficient."
    },
    "covar_pop": {
      "syntax": "covar_pop(y, x)",
      "description": "The population covariance, which does not include bias correction."
    },
    "covar_samp": {
      "syntax": "covar_samp(y, x)",
      "description": "The sample covariance, which includes Bessel's bias correction."
    },
    "entropy": {
      "syntax": "entropy(x)",
      "description": "The log-2 entropy."
    },
    "kurtosis_pop": {
      "syntax": "kurtosis_pop(x)",
      "description": "The excess kurtosis (Fisher’s definition) without bias correction."
    },
    "kurtosis": {
      "syntax": "kurtosis(x)",
      "description": "The excess kurtosis (Fisher's definition) with bias correction according to the sample size."
    },
    "mad": {
      "syntax": "mad(x)",
      "description": "The median absolute deviation. Temporal types return a positive `INTERVAL`."
    },
    "median": {
      "syntax": "median(x)",
      "description": "The middle value of the set. For even value counts, quantitative values are averaged and ordinal values return the lower value."
    },
    "mode": {
      "syntax": "mode(x)",
      "description": "The most frequent value. This function is [affected by ordering](#order-by-clause-in-aggregate-functions)."
    },
    "quantile_cont": {
      "syntax": "quantile_cont(x, pos)",
      "description": "The interpolated `pos`-quantile of `x` for `0 <= pos <= 1`. Returns the `pos * (n_nonnull_values - 1)`th (zero-indexed, in the specified order) value of `x` or an interpolation between the adjacent values if the index is not an integer. Intuitively, arranges the values of `x` as equispaced *points* on a line, starting at 0 and ending at 1, and returns the (interpolated) value at `pos`. If `pos` is a `LIST` of `FLOAT`s, then the result is a `LIST` of the corresponding interpolated quantiles."
    },
    "quantile_disc": {
      "syntax": "quantile_disc(x, pos)",
      "description": "The discrete `pos`-quantile of `x` for `0 <= pos <= 1`. Returns  the `greatest(ceil(pos * n_nonnull_values) - 1, 0)`th (zero-indexed, in the specified order) value of `x`. Intuitively, assigns to each value of `x` an equisized *sub-interval* (left-open and right-closed except for the initial interval) of the interval `[0, 1]`, and picks the value of the sub-interval that contains `pos`. If `pos` is a `LIST` of `FLOAT`s, then the result is a `LIST` of the corresponding discrete quantiles."
    },
    "regr_avgx": {
      "syntax": "regr_avgx(y, x)",
      "description": "The average of the independent variable for non-`NULL` pairs, where x is the independent variable and y is the dependent variable."
    },
    "regr_avgy": {
      "syntax": "regr_avgy(y, x)",
      "description": "The average of the dependent variable for non-`NULL` pairs, where x is the independent variable and y is the dependent variable."
    },
    "regr_count": {
      "syntax": "regr_count(y, x)",
      "description": "The number of non-`NULL` pairs."
    },
    "regr_intercept": {
      "syntax": "regr_intercept(y, x)",
      "description": "The intercept of the univariate linear regression line, where x is the independent variable and y is the dependent variable."
    },
    "regr_r2": {
      "syntax": "regr_r2(y, x)",
      "description": "The squared Pearson correlation coefficient between y and x. Also: The coefficient of determination in a linear regression, where x is the independent variable and y is the dependent variable."
    },
    "regr_slope": {
      "syntax": "regr_slope(y, x)",
      "description": "The slope of the linear regression line, where x is the independent variable and y is the dependent variable."
    },
    "regr_sxx": {
      "syntax": "regr_sxx(y, x)",
      "description": "The population variance, which includes Bessel's bias correction, of the independent variable for non-`NULL` pairs, where x is the independent variable and y is the dependent variable."
    },
    "regr_sxy": {
      "syntax": "regr_sxy(y, x)",
      "description": "The population covariance, which includes Bessel's bias correction."
    },
    "regr_syy": {
      "syntax": "regr_syy(y, x)",
      "description": "The population variance, which includes Bessel's bias correction, of the dependent variable for non-`NULL` pairs , where x is the independent variable and y is the dependent variable."
    },
    "skewness": {
      "syntax": "skewness(x)",
      "description": "The skewness."
    },
    "stddev_pop": {
      "syntax": "stddev_pop(x)",
      "description": "The population standard deviation."
    },
    "stddev_samp": {
      "syntax": "stddev_samp(x)",
      "description": "The sample standard deviation."
    },
    "var_pop": {
      "syntax": "var_pop(x)",
      "description": "The population variance, which does not include bias correction."
    },
    "var_samp": {
      "syntax": "var_samp(x)",
      "description": "The sample variance, which includes Bessel's bias correction."
    },
    "grouping": {
      "syntax": "grouping()",
      "description": "For queries with `GROUP BY` and either [`ROLLUP` or `GROUPING SETS`]({% link docs/sql/query_syntax/grouping_sets.md %}#identifying-grouping-sets-with-grouping_id): Returns an integer identifying which of the argument expressions where used to group on to create the current supper-aggregate row."
    },
    "array_value": {
      "syntax": "array_value(index)",
      "description": "Create an `ARRAY` containing the argument values."
    },
    "array_cross_product": {
      "syntax": "array_cross_product(array1, array2)",
      "description": "Compute the cross product of two arrays of size 3. The array elements can not be `NULL`."
    },
    "array_cosine_similarity": {
      "syntax": "array_cosine_similarity(array1, array2)",
      "description": "Compute the cosine similarity between two arrays of the same size. The array elements can not be `NULL`. The arrays can have any size as long as the size is the same for both arguments."
    },
    "array_cosine_distance": {
      "syntax": "array_cosine_distance(array1, array2)",
      "description": "Compute the cosine distance between two arrays of the same size. The array elements can not be `NULL`. The arrays can have any size as long as the size is the same for both arguments. This is equivalent to `1.0 - array_cosine_similarity`."
    },
    "array_distance": {
      "syntax": "array_distance(array1, array2)",
      "description": "Compute the distance between two arrays of the same size. The array elements can not be `NULL`. The arrays can have any size as long as the size is the same for both arguments."
    },
    "array_inner_product": {
      "syntax": "array_inner_product(array1, array2)",
      "description": "Compute the inner product between two arrays of the same size. The array elements can not be `NULL`. The arrays can have any size as long as the size is the same for both arguments."
    },
    "array_negative_inner_product": {
      "syntax": "array_negative_inner_product(array1, array2)",
      "description": "Compute the negative inner product between two arrays of the same size. The array elements can not be `NULL`. The arrays can have any size as long as the size is the same for both arguments. This is equivalent to `-array_inner_product`."
    },
    "array_dot_product": {
      "syntax": "array_dot_product(array1, array2)",
      "description": "Alias for `array_inner_product(array1, array2)`."
    },
    "array_negative_dot_product": {
      "syntax": "array_negative_dot_product(array1, array2)",
      "description": "Alias for `array_negative_inner_product(array1, array2)`."
    },
    "bit_count": {
      "syntax": "bit_count(x)",
      "description": "Returns the number of bits that are set."
    },
    "bit_length": {
      "syntax": "bit_length(bitstring)",
      "description": "Returns the number of bits in the bitstring."
    },
    "bit_position": {
      "syntax": "bit_position(substring, bitstring)",
      "description": "Returns first starting index of the specified substring within bits, or zero if it's not present. The first (leftmost) bit is indexed 1."
    },
    "bitstring": {
      "syntax": "bitstring(bitstring, length)",
      "description": "Returns a bitstring of determined length."
    },
    "get_bit": {
      "syntax": "get_bit(bitstring, index)",
      "description": "Extracts the nth bit from bitstring; the first (leftmost) bit is indexed 0."
    },
    "length": {
      "syntax": "length(bitstring)",
      "description": "Alias for `bit_length`."
    },
    "octet_length": {
      "syntax": "octet_length(blob)",
      "description": "Number of bytes in `blob`."
    },
    "set_bit": {
      "syntax": "set_bit(bitstring, index, new_value)",
      "description": "Sets the nth bit in bitstring to newvalue; the first (leftmost) bit is indexed 0. Returns a new bitstring."
    },
    "blob || blob": {
      "syntax": "blob || blob",
      "description": "`BLOB` concatenation."
    },
    "decode": {
      "syntax": "decode(blob)",
      "description": "Converts `blob` to `VARCHAR`. Fails if `blob` is not valid UTF-8."
    },
    "encode": {
      "syntax": "encode(string)",
      "description": "Converts the `string` to `BLOB`. Converts UTF-8 characters into literal encoding."
    },
    "hex": {
      "syntax": "hex(blob)",
      "description": "Converts `blob` to `VARCHAR` using hexadecimal encoding."
    },
    "read_blob": {
      "syntax": "read_blob(source)",
      "description": "Returns the content from `source` (a filename, a list of filenames, or a glob pattern) as a `BLOB`. See the [`read_blob` guide]({% link docs/guides/file_formats/read_file.md %}#read_blob) for more details."
    },
    "current_date": {
      "syntax": "current_date",
      "description": "Current date (at start of current transaction) in the local time zone. Note that parentheses should be omitted from the function call."
    },
    "date_add": {
      "syntax": "date_add(date, interval)",
      "description": "Add the interval to the date."
    },
    "date_diff": {
      "syntax": "date_diff(part, startdate, enddate)",
      "description": "The number of [partition]({% link docs/sql/functions/datepart.md %}) boundaries between the timestamps."
    },
    "date_part": {
      "syntax": "date_part(part, timestamptz)",
      "description": "Get [subfield]({% link docs/sql/functions/datepart.md %}) (equivalent to *extract*)."
    },
    "date_sub": {
      "syntax": "date_sub(part, startdate, enddate)",
      "description": "The number of complete [partitions]({% link docs/sql/functions/datepart.md %}) between the timestamps."
    },
    "date_trunc": {
      "syntax": "date_trunc(part, timestamptz)",
      "description": "Truncate to specified [precision]({% link docs/sql/functions/datepart.md %})."
    },
    "datediff": {
      "syntax": "datediff(part, startdate, enddate)",
      "description": "Alias of date_diff. The number of [partition]({% link docs/sql/functions/datepart.md %}) boundaries between the timestamps."
    },
    "datepart": {
      "syntax": "datepart(part, timestamptz)",
      "description": "Alias of date_part. Get [subfield]({% link docs/sql/functions/datepart.md %}) (equivalent to *extract*)."
    },
    "datesub": {
      "syntax": "datesub(part, startdate, enddate)",
      "description": "Alias of date_sub. The number of complete [partitions]({% link docs/sql/functions/datepart.md %}) between the timestamps."
    },
    "datetrunc": {
      "syntax": "datetrunc(part, timestamptz)",
      "description": "Alias of date_trunc. Truncate to specified [precision]({% link docs/sql/functions/datepart.md %})."
    },
    "dayname": {
      "syntax": "dayname(timestamp)",
      "description": "The (English) name of the weekday."
    },
    "extract": {
      "syntax": "extract(field FROM timestamptz)",
      "description": "Get [subfield]({% link docs/sql/functions/datepart.md %}) from a `TIMESTAMP WITH TIME ZONE`."
    },
    "greatest": {
      "syntax": "greatest(timestamptz, timestamptz)",
      "description": "The later of two timestamps."
    },
    "isfinite": {
      "syntax": "isfinite(timestamptz)",
      "description": "Returns true if the timestamp with time zone is finite, false otherwise."
    },
    "isinf": {
      "syntax": "isinf(timestamptz)",
      "description": "Returns true if the timestamp with time zone is infinite, false otherwise."
    },
    "last_day": {
      "syntax": "last_day(timestamptz)",
      "description": "The last day of the month."
    },
    "least": {
      "syntax": "least(timestamptz, timestamptz)",
      "description": "The earlier of two timestamps."
    },
    "make_date": {
      "syntax": "make_date(year, month, day)",
      "description": "The date for the given parts."
    },
    "monthname": {
      "syntax": "monthname(timestamp)",
      "description": "The (English) name of the month."
    },
    "strftime": {
      "syntax": "strftime(timestamptz, format)",
      "description": "Converts a `TIMESTAMP WITH TIME ZONE` value to string according to the [format string]({% link docs/sql/functions/dateformat.md %}#format-specifiers)."
    },
    "time_bucket": {
      "syntax": "time_bucket(bucket_width, timestamptz[, timezone])",
      "description": "Truncate `timestamptz` by the specified interval `bucket_width`. Bucket starts and ends are calculated using `timezone`. `timezone` is a varchar and defaults to UTC."
    },
    "today": {
      "syntax": "today()",
      "description": "Current date (start of current transaction) in UTC."
    },
    "century": {
      "syntax": "century(timestamp)",
      "description": "Extracts the century of a timestamp."
    },
    "day": {
      "syntax": "day(date)",
      "description": "Day."
    },
    "dayofmonth": {
      "syntax": "dayofmonth(date)",
      "description": "Day (synonym)."
    },
    "dayofweek": {
      "syntax": "dayofweek(date)",
      "description": "Numeric weekday (Sunday = 0, Saturday = 6)."
    },
    "dayofyear": {
      "syntax": "dayofyear(date)",
      "description": "Day of the year (starts from 1, i.e., January 1 = 1)."
    },
    "decade": {
      "syntax": "decade(date)",
      "description": "Decade (year / 10)."
    },
    "epoch": {
      "syntax": "epoch(timestamp)",
      "description": "Returns the total number of seconds since the epoch."
    },
    "era": {
      "syntax": "era(date)",
      "description": "Calendar era."
    },
    "hour": {
      "syntax": "hour(date)",
      "description": "Hours."
    },
    "isodow": {
      "syntax": "isodow(date)",
      "description": "Numeric ISO weekday (Monday = 1, Sunday = 7)."
    },
    "isoyear": {
      "syntax": "isoyear(date)",
      "description": "ISO Year number (Starts on Monday of week containing Jan 4th)."
    },
    "microsecond": {
      "syntax": "microsecond(date)",
      "description": "Sub-minute microseconds."
    },
    "millennium": {
      "syntax": "millennium(date)",
      "description": "Millennium."
    },
    "millisecond": {
      "syntax": "millisecond(date)",
      "description": "Sub-minute milliseconds."
    },
    "minute": {
      "syntax": "minute(date)",
      "description": "Minutes."
    },
    "month": {
      "syntax": "month(date)",
      "description": "Month."
    },
    "quarter": {
      "syntax": "quarter(date)",
      "description": "Quarter."
    },
    "second": {
      "syntax": "second(date)",
      "description": "Seconds."
    },
    "timezone_hour": {
      "syntax": "timezone_hour(date)",
      "description": "Time zone offset hour portion."
    },
    "timezone_minute": {
      "syntax": "timezone_minute(date)",
      "description": "Time zone offset minutes portion."
    },
    "timezone": {
      "syntax": "timezone(text, timestamptz)",
      "description": "Use the [date parts]({% link docs/sql/functions/datepart.md %}) of the timestamp in the given time zone to construct a timestamp. Effectively, the result is a “local” time."
    },
    "week": {
      "syntax": "week(date)",
      "description": "ISO Week."
    },
    "weekday": {
      "syntax": "weekday(date)",
      "description": "Numeric weekday synonym (Sunday = 0, Saturday = 6)."
    },
    "weekofyear": {
      "syntax": "weekofyear(date)",
      "description": "ISO Week (synonym)."
    },
    "year": {
      "syntax": "year(date)",
      "description": "Year."
    },
    "yearweek": {
      "syntax": "yearweek(date)",
      "description": "`BIGINT` of combined ISO Year number and 2-digit version of ISO Week number."
    },
    "duckdb_columns": {
      "syntax": "duckdb_columns()",
      "description": "Provides metadata about the columns available in the DuckDB instance"
    },
    "duckdb_constraints": {
      "syntax": "duckdb_constraints()",
      "description": "Provides metadata about the constraints available in the DuckDB instance"
    },
    "duckdb_databases": {
      "syntax": "duckdb_databases()",
      "description": "Lists the databases that are accessible from within the current DuckDB process"
    },
    "duckdb_dependencies": {
      "syntax": "duckdb_dependencies()",
      "description": "Provides metadata about the dependencies available in the DuckDB instance"
    },
    "duckdb_extensions": {
      "syntax": "duckdb_extensions()",
      "description": "Provides metadata about the extensions available in the DuckDB instance"
    },
    "duckdb_functions": {
      "syntax": "duckdb_functions()",
      "description": "Provides metadata about the functions (including macros) available in the DuckDB instance"
    },
    "duckdb_indexes": {
      "syntax": "duckdb_indexes()",
      "description": "Provides metadata about secondary indexes available in the DuckDB instance"
    },
    "duckdb_keywords": {
      "syntax": "duckdb_keywords()",
      "description": "Provides metadata about DuckDB's keywords and reserved words"
    },
    "duckdb_memory": {
      "syntax": "duckdb_memory()",
      "description": "Provides metadata about DuckDB's buffer manager"
    },
    "duckdb_optimizers": {
      "syntax": "duckdb_optimizers()",
      "description": "Provides metadata about the optimization rules available in the DuckDB instance"
    },
    "duckdb_schemas": {
      "syntax": "duckdb_schemas()",
      "description": "Provides metadata about the schemas available in the DuckDB instance"
    },
    "duckdb_secrets": {
      "syntax": "duckdb_secrets()",
      "description": "Provides metadata about the secrets available in the DuckDB instance"
    },
    "duckdb_sequences": {
      "syntax": "duckdb_sequences()",
      "description": "Provides metadata about the sequences available in the DuckDB instance"
    },
    "duckdb_settings": {
      "syntax": "duckdb_settings()",
      "description": "Provides metadata about the settings available in the DuckDB instance"
    },
    "duckdb_tables": {
      "syntax": "duckdb_tables()",
      "description": "Provides metadata about the base tables available in the DuckDB instance"
    },
    "duckdb_temporary_files": {
      "syntax": "duckdb_temporary_files()",
      "description": "Provides metadata about the temporary files DuckDB has written to disk"
    },
    "duckdb_types": {
      "syntax": "duckdb_types()",
      "description": "Provides metadata about the data types available in the DuckDB instance"
    },
    "duckdb_variables": {
      "syntax": "duckdb_variables()",
      "description": "Provides metadata about the variables available in the DuckDB instance"
    },
    "duckdb_views": {
      "syntax": "duckdb_views()",
      "description": "Provides metadata about the views available in the DuckDB instance"
    },
    "enum_code": {
      "syntax": "enum_code(enum_value)",
      "description": "Returns the numeric value backing the given enum value."
    },
    "enum_first": {
      "syntax": "enum_first(enum)",
      "description": "Returns the first value of the input enum type."
    },
    "enum_last": {
      "syntax": "enum_last(enum)",
      "description": "Returns the last value of the input enum type."
    },
    "enum_range": {
      "syntax": "enum_range(enum)",
      "description": "Returns all values of the input enum type as an array."
    },
    "enum_range_boundary": {
      "syntax": "enum_range_boundary(enum, enum)",
      "description": "Returns the range between the two given enum values as an array."
    },
    "to_centuries": {
      "syntax": "to_centuries(integer)",
      "description": "Construct a century interval."
    },
    "to_days": {
      "syntax": "to_days(integer)",
      "description": "Construct a day interval."
    },
    "to_decades": {
      "syntax": "to_decades(integer)",
      "description": "Construct a decade interval."
    },
    "to_hours": {
      "syntax": "to_hours(integer)",
      "description": "Construct an hour interval."
    },
    "to_microseconds": {
      "syntax": "to_microseconds(integer)",
      "description": "Construct a microsecond interval."
    },
    "to_millennia": {
      "syntax": "to_millennia(integer)",
      "description": "Construct a millennium interval."
    },
    "to_milliseconds": {
      "syntax": "to_milliseconds(integer)",
      "description": "Construct a millisecond interval."
    },
    "to_minutes": {
      "syntax": "to_minutes(integer)",
      "description": "Construct a minute interval."
    },
    "to_months": {
      "syntax": "to_months(integer)",
      "description": "Construct a month interval."
    },
    "to_seconds": {
      "syntax": "to_seconds(integer)",
      "description": "Construct a second interval."
    },
    "to_weeks": {
      "syntax": "to_weeks(integer)",
      "description": "Construct a week interval."
    },
    "to_years": {
      "syntax": "to_years(integer)",
      "description": "Construct a year interval."
    },
    "list_transform": {
      "syntax": "list_transform(list, lambda)",
      "description": "Returns a list that is the result of applying the lambda function to each element of the input list. See the [Lambda Functions]({% link docs/sql/functions/lambda.md %}#transform) page for more details."
    },
    "list_filter": {
      "syntax": "list_filter(list, lambda)",
      "description": "Constructs a list from those elements of the input list for which the lambda function returns true. See the [Lambda Functions]({% link docs/sql/functions/lambda.md %}#filter) page for more details."
    },
    "list_reduce": {
      "syntax": "list_reduce(list, lambda)",
      "description": "Returns a single value that is the result of applying the lambda function to each element of the input list. See the [Lambda Functions]({% link docs/sql/functions/lambda.md %}#reduce) page for more details."
    },
    "list[index]": {
      "syntax": "list[index]",
      "description": "Bracket notation serves as an alias for `list_extract`."
    },
    "list[begin:end]": {
      "syntax": "list[begin:end]",
      "description": "Bracket notation with colon is an alias for `list_slice`."
    },
    "list[begin:end:step]": {
      "syntax": "list[begin:end:step]",
      "description": "`list_slice` in bracket notation with an added `step` feature."
    },
    "array_pop_back": {
      "syntax": "array_pop_back(list)",
      "description": "Returns the list without the last element."
    },
    "array_pop_front": {
      "syntax": "array_pop_front(list)",
      "description": "Returns the list without the first element."
    },
    "flatten": {
      "syntax": "flatten(list_of_lists)",
      "description": "Concatenate a list of lists into a single list. This only flattens one level of the list (see [examples](#flattening))."
    },
    "len": {
      "syntax": "len(list)",
      "description": "Return the length of the list."
    },
    "list_aggregate": {
      "syntax": "list_aggregate(list, name)",
      "description": "Executes the aggregate function `name` on the elements of `list`. See the [List Aggregates]({% link docs/sql/functions/list.md %}#list-aggregates) section for more details."
    },
    "list_any_value": {
      "syntax": "list_any_value(list)",
      "description": "Returns the first non-null value in the list."
    },
    "list_append": {
      "syntax": "list_append(list, element)",
      "description": "Appends `element` to `list`."
    },
    "list_concat": {
      "syntax": "list_concat(list1, list2)",
      "description": "Concatenate two lists. NULL inputs are skipped. See also `"
    },
    "list_contains": {
      "syntax": "list_contains(list, element)",
      "description": "Returns true if the list contains the element."
    },
    "list_cosine_similarity": {
      "syntax": "list_cosine_similarity(list1, list2)",
      "description": "Compute the cosine similarity between two lists."
    },
    "list_cosine_distance": {
      "syntax": "list_cosine_distance(list1, list2)",
      "description": "Compute the cosine distance between two lists. Equivalent to `1.0 - list_cosine_similarity`."
    },
    "list_distance": {
      "syntax": "list_distance(list1, list2)",
      "description": "Calculates the Euclidean distance between two points with coordinates given in two inputs lists of equal length."
    },
    "list_distinct": {
      "syntax": "list_distinct(list)",
      "description": "Removes all duplicates and `NULL` values from a list. Does not preserve the original order."
    },
    "list_dot_product": {
      "syntax": "list_dot_product(list1, list2)",
      "description": "Computes the dot product of two same-sized lists of numbers."
    },
    "list_negative_dot_product": {
      "syntax": "list_negative_dot_product(list1, list2)",
      "description": "Computes the negative dot product of two same-sized lists of numbers. Equivalent to `- list_dot_product`."
    },
    "list_extract": {
      "syntax": "list_extract(list, index)",
      "description": "Extract the `index`th (1-based) value from the list."
    },
    "list_grade_up": {
      "syntax": "list_grade_up(list)",
      "description": "Works like sort, but the results are the indexes that correspond to the position in the original `list` instead of the actual values."
    },
    "list_has_all": {
      "syntax": "list_has_all(list, sub-list)",
      "description": "Returns true if all elements of sub-list exist in list."
    },
    "list_has_any": {
      "syntax": "list_has_any(list1, list2)",
      "description": "Returns true if any elements exist is both lists."
    },
    "list_intersect": {
      "syntax": "list_intersect(list1, list2)",
      "description": "Returns a list of all the elements that exist in both `l1` and `l2`, without duplicates."
    },
    "list_position": {
      "syntax": "list_position(list, element)",
      "description": "Returns the index of the element if the list contains the element. If the element is not found, it returns `NULL`."
    },
    "list_prepend": {
      "syntax": "list_prepend(element, list)",
      "description": "Prepends `element` to `list`."
    },
    "list_resize": {
      "syntax": "list_resize(list, size[, value])",
      "description": "Resizes the list to contain `size` elements. Initializes new elements with `value` or `NULL` if `value` is not set."
    },
    "list_reverse_sort": {
      "syntax": "list_reverse_sort(list)",
      "description": "Sorts the elements of the list in reverse order. See the [Sorting Lists]({% link docs/sql/functions/list.md %}#sorting-lists) section for more details about the `NULL` sorting order."
    },
    "list_reverse": {
      "syntax": "list_reverse(list)",
      "description": "Reverses the list."
    },
    "list_select": {
      "syntax": "list_select(value_list, index_list)",
      "description": "Returns a list based on the elements selected by the `index_list`."
    },
    "list_slice": {
      "syntax": "list_slice(list, begin, end)",
      "description": "Extract a sublist using slice conventions. Negative values are accepted. See [slicing]({% link docs/sql/functions/list.md %}#slicing)."
    },
    "list_sort": {
      "syntax": "list_sort(list)",
      "description": "Sorts the elements of the list. See the [Sorting Lists]({% link docs/sql/functions/list.md %}#sorting-lists) section for more details about the sorting order and the `NULL` sorting order."
    },
    "list_unique": {
      "syntax": "list_unique(list)",
      "description": "Counts the unique elements of a list."
    },
    "list_value": {
      "syntax": "list_value(any, ...)",
      "description": "Create a `LIST` containing the argument values."
    },
    "list_where": {
      "syntax": "list_where(value_list, mask_list)",
      "description": "Returns a list with the `BOOLEAN`s in `mask_list` applied as a mask to the `value_list`."
    },
    "list_zip": {
      "syntax": "list_zip(list_1, list_2, ...[, truncate])",
      "description": "Zips _k_ `LIST`s to a new `LIST` whose length will be that of the longest list. Its elements are structs of _k_ elements from each list `list_1`, ..., `list_k`, missing elements are replaced with `NULL`. If `truncate` is set, all lists are truncated to the smallest list length."
    },
    "unnest": {
      "syntax": "unnest(list)",
      "description": "Unnests a list by one level. Note that this is a special function that alters the cardinality of the result. See the [`unnest` page]({% link docs/sql/query_syntax/unnest.md %}) for more details."
    },
    "cardinality": {
      "syntax": "cardinality(map)",
      "description": "Return the size of the map (or the number of entries in the map)."
    },
    "element_at": {
      "syntax": "element_at(map, key)",
      "description": "Return the value for a given key, or `NULL` if the key is not contained in the map. The type of the key provided in the second parameter must match the type of the map's keys else an error is returned."
    },
    "map_contains": {
      "syntax": "map_contains(map, key)",
      "description": "Checks if a map contains a given key."
    },
    "map_contains_entry": {
      "syntax": "map_contains_entry(map, key, value)",
      "description": "Check if a map contains a given key-value pair."
    },
    "map_contains_value": {
      "syntax": "map_contains_value(map, value)",
      "description": "Checks if a map contains a given value."
    },
    "map_entries": {
      "syntax": "map_entries(map)",
      "description": "Return a list of struct(k, v) for each key-value pair in the map."
    },
    "map_extract": {
      "syntax": "map_extract(map, key)",
      "description": "Return the value for a given key, or `NULL` if the key is not contained in the map. The type of the key provided in the second parameter must match the type of the map's keys else an error is returned."
    },
    "map_from_entries": {
      "syntax": "map_from_entries(STRUCT(k, v)[])",
      "description": "Returns a map created from the entries of the array."
    },
    "map_keys": {
      "syntax": "map_keys(map)",
      "description": "Return a list of all keys in the map."
    },
    "map_values": {
      "syntax": "map_values(map)",
      "description": "Return a list of all values in the map."
    },
    "map": {
      "syntax": "map()",
      "description": "Returns an empty map."
    },
    "map[entry]": {
      "syntax": "map[entry]",
      "description": "Return the value for a given key, or `NULL` if the key is not contained in the map. The type of the key provided in the second parameter must match the type of the map's keys else an error is returned."
    },
    "@": {
      "syntax": "@(x)",
      "description": "Absolute value. Parentheses are optional if `x` is a column name."
    },
    "abs": {
      "syntax": "abs(x)",
      "description": "Absolute value."
    },
    "acos": {
      "syntax": "acos(x)",
      "description": "Computes the arccosine of `x`."
    },
    "add": {
      "syntax": "add(x, y)",
      "description": "Alias for `x + y`."
    },
    "asin": {
      "syntax": "asin(x)",
      "description": "Computes the arcsine of `x`."
    },
    "atan": {
      "syntax": "atan(x)",
      "description": "Computes the arctangent of `x`."
    },
    "atan2": {
      "syntax": "atan2(y, x)",
      "description": "Computes the arctangent `(y, x)`."
    },
    "cbrt": {
      "syntax": "cbrt(x)",
      "description": "Returns the cube root of the number."
    },
    "ceil": {
      "syntax": "ceil(x)",
      "description": "Rounds the number up."
    },
    "ceiling": {
      "syntax": "ceiling(x)",
      "description": "Rounds the number up. Alias of `ceil`."
    },
    "cos": {
      "syntax": "cos(x)",
      "description": "Computes the cosine of `x`."
    },
    "cot": {
      "syntax": "cot(x)",
      "description": "Computes the cotangent of `x`."
    },
    "degrees": {
      "syntax": "degrees(x)",
      "description": "Converts radians to degrees."
    },
    "divide": {
      "syntax": "divide(x, y)",
      "description": "Alias for `x // y`."
    },
    "even": {
      "syntax": "even(x)",
      "description": "Round to next even number by rounding away from zero."
    },
    "exp": {
      "syntax": "exp(x)",
      "description": "Computes `e ** x`."
    },
    "factorial": {
      "syntax": "factorial(x)",
      "description": "See `!` operator. Computes the product of the current integer and all integers below it."
    },
    "fdiv": {
      "syntax": "fdiv(x, y)",
      "description": "Performs integer division (`x // y`) but returns a `DOUBLE` value."
    },
    "floor": {
      "syntax": "floor(x)",
      "description": "Rounds the number down."
    },
    "fmod": {
      "syntax": "fmod(x, y)",
      "description": "Calculates the modulo value. Always returns a `DOUBLE` value."
    },
    "gamma": {
      "syntax": "gamma(x)",
      "description": "Interpolation of the factorial of `x - 1`. Fractional inputs are allowed."
    },
    "gcd": {
      "syntax": "gcd(x, y)",
      "description": "Computes the greatest common divisor of `x` and `y`."
    },
    "greatest_common_divisor": {
      "syntax": "greatest_common_divisor(x, y)",
      "description": "Computes the greatest common divisor of `x` and `y`."
    },
    "isnan": {
      "syntax": "isnan(x)",
      "description": "Returns true if the floating point value is not a number, false otherwise."
    },
    "lcm": {
      "syntax": "lcm(x, y)",
      "description": "Computes the least common multiple of `x` and `y`."
    },
    "least_common_multiple": {
      "syntax": "least_common_multiple(x, y)",
      "description": "Computes the least common multiple of `x` and `y`."
    },
    "lgamma": {
      "syntax": "lgamma(x)",
      "description": "Computes the log of the `gamma` function."
    },
    "ln": {
      "syntax": "ln(x)",
      "description": "Computes the natural logarithm of `x`."
    },
    "log": {
      "syntax": "log(x)",
      "description": "Computes the base-10 logarithm of `x`."
    },
    "log10": {
      "syntax": "log10(x)",
      "description": "Alias of `log`. Computes the base-10 logarithm of `x`."
    },
    "log2": {
      "syntax": "log2(x)",
      "description": "Computes the base-2 log of `x`."
    },
    "multiply": {
      "syntax": "multiply(x, y)",
      "description": "Alias for `x * y`."
    },
    "nextafter": {
      "syntax": "nextafter(x, y)",
      "description": "Return the next floating point value after `x` in the direction of `y`."
    },
    "pi": {
      "syntax": "pi()",
      "description": "Returns the value of pi."
    },
    "pow": {
      "syntax": "pow(x, y)",
      "description": "Computes `x` to the power of `y`."
    },
    "power": {
      "syntax": "power(x, y)",
      "description": "Alias of `pow`. computes `x` to the power of `y`."
    },
    "radians": {
      "syntax": "radians(x)",
      "description": "Converts degrees to radians."
    },
    "random": {
      "syntax": "random()",
      "description": "Returns a random number `x` in the range `0.0 <= x < 1.0`."
    },
    "round_even": {
      "syntax": "round_even(v NUMERIC, s INTEGER)",
      "description": "Alias of `roundbankers(v, s)`. Round to `s` decimal places using the [_rounding half to even_ rule](https://en.wikipedia.org/wiki/Rounding#Rounding_half_to_even). Values `s < 0` are allowed."
    },
    "round": {
      "syntax": "round(v NUMERIC, s INTEGER)",
      "description": "Round to `s` decimal places. Values `s < 0` are allowed."
    },
    "setseed": {
      "syntax": "setseed(x)",
      "description": "Sets the seed to be used for the random function."
    },
    "sign": {
      "syntax": "sign(x)",
      "description": "Returns the sign of `x` as -1, 0 or 1."
    },
    "signbit": {
      "syntax": "signbit(x)",
      "description": "Returns whether the signbit is set or not."
    },
    "sin": {
      "syntax": "sin(x)",
      "description": "Computes the sin of `x`."
    },
    "sqrt": {
      "syntax": "sqrt(x)",
      "description": "Returns the square root of the number."
    },
    "subtract": {
      "syntax": "subtract(x, y)",
      "description": "Alias for `x - y`."
    },
    "tan": {
      "syntax": "tan(x)",
      "description": "Computes the tangent of `x`."
    },
    "trunc": {
      "syntax": "trunc(x)",
      "description": "Truncates the number."
    },
    "xor": {
      "syntax": "xor(x, y)",
      "description": "Bitwise XOR."
    },
    "regexp_extract": {
      "syntax": "regexp_extract(string, pattern, name_list[, options])",
      "description": "If `string` contains the regexp `pattern`, returns the capturing groups as a struct with corresponding names from `name_list`; otherwise, returns a struct with the same keys and empty strings as values."
    },
    "regexp_extract_all": {
      "syntax": "regexp_extract_all(string, regex[, group = 0][, options])",
      "description": "Finds non-overlapping occurrences of `regex` in `string` and returns the corresponding values of `group`."
    },
    "regexp_full_match": {
      "syntax": "regexp_full_match(string, regex[, options])",
      "description": "Returns `true` if the entire `string` matches the `regex`."
    },
    "regexp_matches": {
      "syntax": "regexp_matches(string, pattern[, options])",
      "description": "Returns `true` if  `string` contains the regexp `pattern`, `false` otherwise."
    },
    "regexp_replace": {
      "syntax": "regexp_replace(string, pattern, replacement[, options])",
      "description": "If `string` contains the regexp `pattern`, replaces the matching part with `replacement`."
    },
    "regexp_split_to_array": {
      "syntax": "regexp_split_to_array(string, regex[, options])",
      "description": "Alias of `string_split_regex`. Splits the `string` along the `regex`."
    },
    "regexp_split_to_table": {
      "syntax": "regexp_split_to_table(string, regex[, options])",
      "description": "Splits the `string` along the `regex` and returns a row for each part."
    },
    "row": {
      "syntax": "row(any, ...)",
      "description": "Create an unnamed `STRUCT` (tuple) containing the argument values."
    },
    "struct_extract": {
      "syntax": "struct_extract(struct, idx)",
      "description": "Extract the entry from an unnamed `STRUCT` (tuple) using an index (1-based)."
    },
    "struct_insert": {
      "syntax": "struct_insert(struct, name := any, ...)",
      "description": "Add field(s)/value(s) to an existing `STRUCT` with the argument values. The entry name(s) will be the bound variable name(s)."
    },
    "struct_pack": {
      "syntax": "struct_pack(name := any, ...)",
      "description": "Create a `STRUCT` containing the argument values. The entry name will be the bound variable name."
    },
    "get_current_time": {
      "syntax": "get_current_time()",
      "description": "Current time (start of current transaction) in UTC."
    },
    "make_time": {
      "syntax": "make_time(bigint, bigint, double)",
      "description": "The time for the given parts."
    },
    "age": {
      "syntax": "age(timestamptz)",
      "description": "Subtract from current_date."
    },
    "current_localtimestamp": {
      "syntax": "current_localtimestamp()",
      "description": "Returns a `TIMESTAMP` whose GMT bin values correspond to local date and time in the current time zone."
    },
    "epoch_ms": {
      "syntax": "epoch_ms(timestamptz)",
      "description": "Converts a timestamptz to milliseconds since the epoch."
    },
    "epoch_ns": {
      "syntax": "epoch_ns(timestamptz)",
      "description": "Converts a timestamptz to nanoseconds since the epoch."
    },
    "epoch_us": {
      "syntax": "epoch_us(timestamptz)",
      "description": "Converts a timestamptz to microseconds since the epoch."
    },
    "make_timestamp": {
      "syntax": "make_timestamp(microseconds)",
      "description": "Converts integer microseconds since the epoch to a timestamp."
    },
    "strptime": {
      "syntax": "strptime(text, format)",
      "description": "Converts string to `TIMESTAMP WITH TIME ZONE` according to the [format string]({% link docs/sql/functions/dateformat.md %}#format-specifiers) if `%Z` is specified."
    },
    "try_strptime": {
      "syntax": "try_strptime(text, format)",
      "description": "Converts the string `text` to timestamp according to the [format string]({% link docs/sql/functions/dateformat.md %}#format-specifiers). Returns `NULL` on failure."
    },
    "generate_series": {
      "syntax": "generate_series(timestamptz, timestamptz, interval)",
      "description": "Generate a table of timestamps in the closed range (including both the starting timestamp and the ending timestamp), stepping by the interval."
    },
    "range": {
      "syntax": "range(timestamptz, timestamptz, interval)",
      "description": "Generate a table of timestamps in the half open range (including the starting timestamp, but stopping before the ending timestamp), stepping by the interval."
    },
    "get_current_timestamp": {
      "syntax": "get_current_timestamp()",
      "description": "Current date and time (start of current transaction)."
    },
    "now": {
      "syntax": "now()",
      "description": "Current date and time (start of current transaction)."
    },
    "to_timestamp": {
      "syntax": "to_timestamp(double)",
      "description": "Converts seconds since the epoch to a timestamp with time zone."
    },
    "transaction_timestamp": {
      "syntax": "transaction_timestamp()",
      "description": "Current date and time (start of current transaction)."
    },
    "make_timestamptz": {
      "syntax": "make_timestamptz(microseconds)",
      "description": "The `TIMESTAMP WITH TIME ZONE` for the given µs since the epoch."
    },
    "current_localtime": {
      "syntax": "current_localtime()",
      "description": "Returns a `TIME` whose GMT bin values correspond to local time in the current time zone."
    },
    "union_extract": {
      "syntax": "union_extract(union, 'tag')",
      "description": "Extract the value with the named tags from the union. `NULL` if the tag is not currently selected."
    },
    "union_value": {
      "syntax": "union_value(tag := any)",
      "description": "Create a single member `UNION` containing the argument value. The tag of the value will be the bound variable name."
    },
    "union_tag": {
      "syntax": "union_tag(union)",
      "description": "Retrieve the currently selected tag of the union as an [Enum]({% link docs/sql/data_types/enum.md %})."
    },
    "alias": {
      "syntax": "alias(column)",
      "description": "Return the name of the column."
    },
    "checkpoint": {
      "syntax": "checkpoint(database)",
      "description": "Synchronize WAL with file for (optional) database without interrupting transactions."
    },
    "coalesce": {
      "syntax": "coalesce(expr, ...)",
      "description": "Return the first expression that evaluates to a non-`NULL` value. Accepts 1 or more parameters. Each expression can be a column, literal value, function result, or many others."
    },
    "constant_or_null": {
      "syntax": "constant_or_null(arg1, arg2)",
      "description": "If `arg2` is `NULL`, return `NULL`. Otherwise, return `arg1`."
    },
    "count_if": {
      "syntax": "count_if(x)",
      "description": "Aggregate function; rows contribute 1 if `x` is `true` or a non-zero number, else 0."
    },
    "current_catalog": {
      "syntax": "current_catalog()",
      "description": "Return the name of the currently active catalog. Default is memory."
    },
    "current_schema": {
      "syntax": "current_schema()",
      "description": "Return the name of the currently active schema. Default is main."
    },
    "current_schemas": {
      "syntax": "current_schemas(boolean)",
      "description": "Return list of schemas. Pass a parameter of `true` to include implicit schemas."
    },
    "current_setting": {
      "syntax": "current_setting('setting_name')",
      "description": "Return the current value of the configuration setting."
    },
    "currval": {
      "syntax": "currval('sequence_name')",
      "description": "Return the current value of the sequence. Note that `nextval` must be called at least once prior to calling `currval`."
    },
    "error": {
      "syntax": "error(message)",
      "description": "Throws the given error `message`."
    },
    "equi_width_bins": {
      "syntax": "equi_width_bins(min, max, bincount, nice := false)",
      "description": "Returns the upper boundaries of a partition of the interval `[min, max]` into `bin_count` equal-sized subintervals (for use with, e.g., [`histogram`]({% link docs/sql/functions/aggregates.md %}#histogramargboundaries)). If `nice = true`, then `min`, `max`, and `bincount` may be adjusted to produce more aesthetically pleasing results."
    },
    "force_checkpoint": {
      "syntax": "force_checkpoint(database)",
      "description": "Synchronize WAL with file for (optional) database interrupting transactions."
    },
    "gen_random_uuid": {
      "syntax": "gen_random_uuid()",
      "description": "Alias of `uuid`. Return a random UUID similar to this: `eeccb8c5-9943-b2bb-bb5e-222f4e14b687`."
    },
    "getenv": {
      "syntax": "getenv(var)",
      "description": "Returns the value of the environment variable `var`. Only available in the [command line client]({% link docs/clients/cli/overview.md %})."
    },
    "hash": {
      "syntax": "hash(value)",
      "description": "Returns a `UBIGINT` with the hash of the `value`."
    },
    "icu_sort_key": {
      "syntax": "icu_sort_key(string, collator)",
      "description": "Surrogate key used to sort special characters according to the specific locale. Collator parameter is optional. Valid only when ICU extension is installed."
    },
    "if": {
      "syntax": "if(a, b, c)",
      "description": "Ternary conditional operator."
    },
    "ifnull": {
      "syntax": "ifnull(expr, other)",
      "description": "A two-argument version of coalesce."
    },
    "is_histogram_other_bin": {
      "syntax": "is_histogram_other_bin(arg)",
      "description": "Returns `true` when `arg` is the \"catch-all element\" of its datatype for the purpose of the [`histogram_exact`]({% link docs/sql/functions/aggregates.md %}#histogram_exactargelements) function, which is equal to the \"right-most boundary\" of its datatype for the purpose of the [`histogram`]({% link docs/sql/functions/aggregates.md %}#histogramargboundaries) function."
    },
    "md5": {
      "syntax": "md5(string)",
      "description": "Returns the MD5 hash of the `string` as a `VARCHAR`."
    },
    "md5_number": {
      "syntax": "md5_number(string)",
      "description": "Returns the MD5 hash of the `string` as a `HUGEINT`."
    },
    "md5_number_lower": {
      "syntax": "md5_number_lower(string)",
      "description": "Returns the lower 64-bit segment of the MD5 hash of the `string` as a `BIGINT`."
    },
    "md5_number_higher": {
      "syntax": "md5_number_higher(string)",
      "description": "Returns the higher 64-bit segment of the MD5 hash of the `string` as a `BIGINT`."
    },
    "nextval": {
      "syntax": "nextval('sequence_name')",
      "description": "Return the following value of the sequence."
    },
    "nullif": {
      "syntax": "nullif(a, b)",
      "description": "Return `NULL` if `a = b`, else return `a`. Equivalent to `CASE WHEN a = b THEN NULL ELSE a END`."
    },
    "pg_typeof": {
      "syntax": "pg_typeof(expression)",
      "description": "Returns the lower case name of the data type of the result of the expression. For PostgreSQL compatibility."
    },
    "read_text": {
      "syntax": "read_text(source)",
      "description": "Returns the content from `source` (a filename, a list of filenames, or a glob pattern) as a `VARCHAR`. The file content is first validated to be valid UTF-8. If `read_text` attempts to read a file with invalid UTF-8 an error is thrown suggesting to use `read_blob` instead. See the [`read_text` guide]({% link docs/guides/file_formats/read_file.md %}#read_text) for more details."
    },
    "sha256": {
      "syntax": "sha256(value)",
      "description": "Returns a `VARCHAR` with the SHA-256 hash of the `value`."
    },
    "stats": {
      "syntax": "stats(expression)",
      "description": "Returns a string with statistics about the expression. Expression can be a column, constant, or SQL expression."
    },
    "txid_current": {
      "syntax": "txid_current()",
      "description": "Returns the current transaction's identifier, a `BIGINT` value. It will assign a new one if the current transaction does not have one already."
    },
    "typeof": {
      "syntax": "typeof(expression)",
      "description": "Returns the name of the data type of the result of the expression."
    },
    "uuid": {
      "syntax": "uuid()",
      "description": "Return a random UUID similar to this: `eeccb8c5-9943-b2bb-bb5e-222f4e14b687`."
    },
    "version": {
      "syntax": "version()",
      "description": "Return the currently active version of DuckDB in this format."
    },
    "glob": {
      "syntax": "glob(search_path)",
      "description": "Return filenames found at the location indicated by the *search_path* in a single column named `file`. The *search_path* may contain [glob pattern matching syntax]({% link docs/sql/functions/pattern_matching.md %})."
    },
    "repeat_row": {
      "syntax": "repeat_row(varargs, num_rows)",
      "description": "Returns a table with `num_rows` rows, each containing the fields defined in `varargs`."
    },
    "cume_dist": {
      "syntax": "cume_dist([ORDER BY ordering])",
      "description": "The cumulative distribution: (number of partition rows preceding or peer with current row) / total partition rows."
    },
    "dense_rank": {
      "syntax": "dense_rank()",
      "description": "The rank of the current row *without gaps;* this function counts peer groups."
    },
    "first_value": {
      "syntax": "first_value(expr[ ORDER BY ordering][ IGNORE NULLS])",
      "description": "Returns `expr` evaluated at the row that is the first row (with a non-null value of `expr` if `IGNORE NULLS` is set) of the window frame."
    },
    "lag": {
      "syntax": "lag(expr[, offset[, default]][ ORDER BY ordering][ IGNORE NULLS])",
      "description": "Returns `expr` evaluated at the row that is `offset` rows (among rows with a non-null value of `expr` if `IGNORE NULLS` is set) before the current row within the window frame; if there is no such row, instead return `default` (which must be of the Same type as `expr`). Both `offset` and `default` are evaluated with respect to the current row. If omitted, `offset` defaults to `1` and default to `NULL`."
    },
    "last_value": {
      "syntax": "last_value(expr[ ORDER BY ordering][ IGNORE NULLS])",
      "description": "Returns `expr` evaluated at the row that is the last row (among rows with a non-null value of `expr` if `IGNORE NULLS` is set) of the window frame."
    },
    "lead": {
      "syntax": "lead(expr[, offset[, default]][ ORDER BY ordering][ IGNORE NULLS])",
      "description": "Returns `expr` evaluated at the row that is `offset` rows after the current row (among rows with a non-null value of `expr` if `IGNORE NULLS` is set) within the window frame; if there is no such row, instead return `default` (which must be of the Same type as `expr`). Both `offset` and `default` are evaluated with respect to the current row. If omitted, `offset` defaults to `1` and default to `NULL`."
    },
    "nth_value": {
      "syntax": "nth_value(expr, nth[ ORDER BY ordering][ IGNORE NULLS])",
      "description": "Returns `expr` evaluated at the nth row (among rows with a non-null value of `expr` if `IGNORE NULLS` is set) of the window frame (counting from 1); `NULL` if no such row."
    },
    "ntile": {
      "syntax": "ntile(num_buckets[ ORDER BY ordering])",
      "description": "An integer ranging from 1 to `num_buckets`, dividing the partition as equally as possible."
    },
    "percent_rank": {
      "syntax": "percent_rank([ORDER BY ordering])",
      "description": "The relative rank of the current row: `(rank() - 1) / (total partition rows - 1)`."
    },
    "rank_dense": {
      "syntax": "rank_dense()",
      "description": "The rank of the current row *without gaps*."
    },
    "rank": {
      "syntax": "rank([ORDER BY ordering])",
      "description": "The rank of the current row *with gaps;* same as `row_number` of its first peer."
    },
    "row_number": {
      "syntax": "row_number([ORDER BY ordering])",
      "description": "The number of the current row within the partition, counting from 1."
    }
  }
