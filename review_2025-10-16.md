# Code Review: Oxidize Branch (Tauri Migration)
**Date:** 2025-10-16
**Branch:** `oxidize` (vs `main`)
**Reviewer:** Multi-Model Analysis (OpenAI, Anthropic, Google via mpt)
**Total Changes:** 296 files, ~47k lines

---

## Review Structure

This PR is reviewed in 4 parts:
1. **Part 1: Tauri Rust Backend** (database, streaming, secrets) ‚úÖ COMPLETED
2. **Part 2: TypeScript Engine Abstraction Layer** (in progress)
3. **Part 3: Frontend Integration & UI Changes** (pending)
4. **Part 4: Tests & Documentation** (pending)

---

## Part 1: Tauri Rust Backend

**Scope:** 48 Rust files (~11.5k lines) in `src-tauri/`

### üî¥ CRITICAL ISSUES (Must Fix Before Merge)

#### 1. Connection Pool Permit Lifetime Bug
**Files:** `src-tauri/src/database/engine.rs:311-332`, `unified_pool.rs:118`

**Issue:**
`OwnedSemaphorePermit` is dropped immediately after connection creation, but persistent connections live on in dedicated threads. This means persistent connections are **not counted toward pool limits**.

**Impact:**
- Pool limits not enforced for persistent connections
- Unbounded connection growth possible
- Resource exhaustion risk

**Fix:**
```rust
// WRONG (current):
let permit = self.pool.acquire_connection_permit().await?;
let conn = tokio::task::spawn_blocking(move || permit.create_connection())...
// permit is dropped here, but connection lives on

// RIGHT:
// Move permit into dedicated thread and store with connection
struct ConnectionGuard {
    connection: Connection,
    _permit: OwnedSemaphorePermit, // Held for connection lifetime
}
```

**Detailed Fix:**
- Change `ThreadSafeConnectionManager::create_connection` to accept `ConnectionPermit`
- Spawn thread, call `permit.create_connection()` inside that thread
- Store `OwnedSemaphorePermit` alongside Connection in `ConnectionHandler`
- Permit released only when ConnectionHandler is dropped

---

#### 2. Thread-Affinity Violation
**Files:** `src-tauri/src/database/engine.rs:310-332`, `unified_pool.rs:118`

**Issue:**
Connection created in `spawn_blocking` thread, then moved to different `std::thread` for `ConnectionHandler`. Violates comment: "This MUST be called from the thread where the connection will be used".

**Impact:**
May break DuckDB's thread-affinity assumptions (connections may not be thread-safe across moves).

**Fix:**
Move `permit.create_connection()` call **inside** the dedicated `std::thread` where `ConnectionHandler` runs, not in `spawn_blocking`.

---

#### 3. Test Compilation Failures
**File:** `src-tauri/src/secrets/tests.rs:84-110`

**Issue:**
Test references non-existent fields:
- `fields.user` (should be `fields.username`)
- `fields.secret` (should be `fields.password`)

**Impact:**
Tests don't compile.

**Fix:**
```rust
// In test_validator_postgres:
assert!(fields.username.is_some()); // not fields.user
assert!(fields.password.is_some()); // not fields.secret
```

---

#### 4. SQL Parameter Binding Vulnerability
**File:** `src-tauri/src/database/sql_sanitizer.rs:138-213`

**Issue:**
Uses string-based parameter substitution instead of true prepared statements:
```rust
pub fn build_parameterized_query(sql: &str, params: &[Value]) -> Result<String> {
    // String replacement with heuristics (in_string tracking)
    match ch {
        '?' if !in_string => {
            result.push_str(&escape_sql_value(&params[param_index])?);
            // Still vulnerable to sophisticated attacks
        }
    }
}
```

**Impact:**
While better than raw concatenation, this is weaker than true bound parameters and may:
- Reject legitimate values (false positives)
- Miss edge cases (false negatives, potential injection)

**Mitigations Applied:**
- ‚úÖ Rejects comments, multi-statements, control characters
- ‚úÖ Tight validation

**Recommendations:**
1. **Document this limitation clearly** (DuckDB Arrow API limitation)
2. Keep tight validation (already done)
3. Limit usage to DML/SELECT; consider rejecting DDL
4. Expose safer high-level API to frontend for parameters distinct from query text
5. Long-term: Migrate to native prepared statements when DuckDB Rust bindings support it

---

### ‚ö†Ô∏è HIGH PRIORITY ISSUES (Should Fix)

#### 5. Async Lock Anti-Pattern
**File:** `src-tauri/src/database/connection_handler.rs:289-331`

**Issue:**
Cleanup loop holds `tokio::sync::Mutex` lock across `await handle.is_idle()`:
```rust
let mut connections = self.connections.lock().await;
for (id, handle) in connections.iter() {
    if handle.is_idle().await { // WRONG: holding lock across await
        // ...
    }
}
```

**Impact:**
Starves other operations that need the connections map (classic async anti-pattern).

**Fix:**
```rust
// Copy handles first, drop lock, then await
let handles: Vec<_> = {
    let connections = self.connections.lock().await;
    connections.iter().map(|(id, h)| (id.clone(), h.clone())).collect()
};
// Lock dropped here

for (id, handle) in handles {
    if handle.is_idle().await { // OK: no lock held
        // Re-lock only for removal
        self.connections.lock().await.remove(&id);
    }
}
```

---

#### 6. Unquoted Secret Name in ATTACH
**File:** `src-tauri/src/database/unified_pool.rs:230-252`

**Issue:**
Secret name used without quoting in re-attach SQL:
```rust
format!("ATTACH ... SECRET {}", secret_name) // Unquoted
```

While current naming (`secret_<uuid>`) is safe, defensive quoting prevents future issues.

**Fix:**
```rust
let secret_ident = format!("\"{}\"", secret_name.replace('"', "\"\""));
format!("ATTACH ... SECRET {}", secret_ident)
```

---

#### 7. Arrow Type Conversion Mismatch
**File:** `src-tauri/src/commands/stream.rs:226-283, 289-595`

**Issue:**
- `convert_duckdb_schema`: Unsupported types fall back to `Utf8`
- `convert_duckdb_batch`: Unsupported types fall back to `NullArray`
- **Schema says Utf8, data is Null ‚Üí type mismatch**

**Impact:**
`RecordBatch::try_new` will error when schema and data don't match.

**Fix Options:**
1. Expand type coverage (Decimal256, Dictionary, List, Struct, Map)
2. **Or** fail fast with clear error for unsupported types
3. **Or** use same fallback (Utf8) in both schema and data conversion

**Performance Note:**
Heavy per-row copying is expensive for large batches. Consider zero-copy forwarding via arrow-flight-like contract (longer term).

---

#### 8. Port Number Integer Truncation
**File:** `src-tauri/src/connections/manager.rs:398-466`

**Issue:**
Converting `i64 -> u16` with `as` cast:
```rust
let port = row.get::<_, i64>(4)? as u16; // Truncation risk
```

**Impact:**
Unexpected values in SQLite DB could truncate silently.

**Fix:**
```rust
let port_i64 = row.get::<_, i64>(4)?;
let port = u16::try_from(port_i64)
    .map_err(|_| ConnectionError::InvalidConfiguration {
        message: format!("Port {} out of valid range 0-65535", port_i64),
    })?;
```

Apply same pattern for `connect_timeout`, `query_timeout`, `max_connections`.

---

### üìã MEDIUM PRIORITY (Improvements)

#### 9. Timeout Enforcement Incomplete
**File:** `src-tauri/src/database/connection_handler.rs:96-109`

**Issue:**
`execute_sql_with_timeout` applies timeout only at async caller level via `tokio::time::timeout`. The connection thread continues running the query after timeout.

**Impact:**
- Head-of-line blocking for subsequent commands on same connection
- DuckDB 1.3 lacks interrupt handles for cancellation

**Recommendation:**
Document this behavior clearly for frontend. When DuckDB adds interrupt support, add cancellation via interrupt handle.

---

#### 10. SQLite Operations Blocking Async Runtime
**File:** `src-tauri/src/persistence.rs:22, 41, 74`

**Issue:**
Using `std::sync::Mutex` in async Tauri commands:
```rust
Arc<Mutex<Connection>> // rusqlite is synchronous
// .lock() inside async code blocks worker thread
```

**Impact:**
With multi-threaded runtime, this may be acceptable but can cause responsiveness issues.

**Recommendation:**
Use `spawn_blocking` for SQLite operations or create a small synchronous pool.

---

#### 11. Window-Based Authorization Insufficient
**File:** `src-tauri/src/secrets/commands.rs:30-40`

**Issue:**
Authorization based on window label:
```rust
if window.label() != "secrets" {
    return Err("Unauthorized: secrets commands only available from secrets window".into());
}
```

**Impact:**
Window labels could potentially be spoofed or manipulated.

**Recommendation:**
Consider capability-based security tokens for more robust authorization.

---

#### 12. Resource Cleanup in Drop
**File:** `src-tauri/src/database/resource_manager.rs:100-150`

**Issue:**
`ResourceGuard` drop spawns async cleanup:
```rust
impl Drop for ResourceGuard {
    fn drop(&mut self) {
        tokio::spawn(async move {
            // If task cancelled during shutdown, resources leak
            manager.used_memory.fetch_sub(used, Ordering::Relaxed);
        });
    }
}
```

**Impact:**
Task might not complete during process shutdown, leaking resource tracking.

**Fix:**
```rust
impl Drop for ResourceGuard {
    fn drop(&mut self) {
        // Synchronous cleanup
        self.manager.used_memory.fetch_sub(self.memory_reserved, Ordering::Relaxed);
    }
}
```

---

#### 13. ATTACH Path Validation in Release
**File:** `src-tauri/src/commands/mod.rs` (debug block in `connection_execute`)

**Issue:**
Debug code calls `validate_attach_path` but proceeds even if it fails.

**Recommendation:**
Ensure production rejects unsafe paths everywhere raw ATTACH strings are accepted, or avoid accepting raw ATTACH from renderer (use structured APIs only).

---

#### 14. Logging Cleanup
**Multiple Files**

**Issue:**
Some use of `eprintln!`/`println!` in production code.

**Recommendation:**
Stick to `tracing` macros. Already gated with `#[cfg(debug_assertions)]` in many places.

---

### ‚úÖ STRENGTHS

1. **Well-Structured Error Handling**
   - Clean error hierarchy with `thiserror`
   - Context preservation with `serde` tagging
   - `src-tauri/src/errors.rs`

2. **Good Architecture Separation**
   - `UnifiedPool`: Connection permits + configuration
   - `ThreadSafeConnectionManager`: Persistent connections
   - `ArrowStreamingExecutor`: Per-query streaming
   - Clear separation of concerns

3. **Security Best Practices**
   - OS keychain integration via `security-framework` (macOS), `windows` crate
   - `Zeroize` and `ZeroizeOnDrop` for sensitive data
   - `SecureString` type that doesn't log values
   - `src-tauri/src/secrets/`

4. **Identifier Sanitization**
   - Good alias sanitization in `attach_remote_database`
   - Proper quoting of SECRET identifiers
   - Path traversal prevention in `validate_attach_path`
   - `src-tauri/src/security/mod.rs`

5. **Backpressure Handling**
   - `MAX_UNACKED_BATCHES = 3` with channel size 1
   - Prevents memory exhaustion in streaming
   - `src-tauri/src/commands/stream.rs:151-205`

6. **Ergonomic API Design**
   - Supports both camelCase and snake_case parameter names
   - `coalesce_param_opt` helper for frontend compatibility
   - `src-tauri/src/commands/utils.rs`

7. **Efficient Binary Streaming**
   - Uses `serde_bytes` for Arrow IPC data
   - Reduces copies between Rust and TypeScript
   - `BinaryStreamEvent` in `stream.rs`

8. **Comprehensive Type System**
   - `ConnectionConfig`, `SecretMetadata`, `DatabaseCredentials` well-modeled
   - Type safety between Rust and TypeScript via `serde`
   - `src-tauri/src/connections/models.rs`, `src-tauri/src/secrets/models.rs`

---

### üìä Detailed Line-Level Notes

#### src-tauri/src/database/engine.rs
- **L311-332** `create_connection`: Pool permit lifetime and thread-affinity issues (see Critical #1, #2)
- **L409-527** `attach_remote_database`: Good alias sanitization and SECRET quoting
- **L576-620** `get_tables`/`get_columns`: Good pattern using `execute_query_with_params`

#### src-tauri/src/database/unified_pool.rs
- **L118**: Comment "MUST be called from the thread where the connection will be used" - honor this invariant
- **L230-252**: ATTACH with SECRET name unquoted (see High Priority #6)

#### src-tauri/src/database/connection_handler.rs
- **L289-331** `start_cleanup_task`: Avoid holding connections lock across awaits (see High Priority #5)
- **L96-109** `execute_sql_with_timeout`: Timeout only applied in caller (see Medium Priority #9)

#### src-tauri/src/commands/stream.rs
- **L134-206**: Backpressure loop - good pattern
- **L226-283** `convert_duckdb_schema`: Fallback to Utf8 for unhandled types
- **L289-595** `convert_duckdb_batch`: NullArray fallback causes schema mismatch (see High Priority #7)

#### src-tauri/src/secrets/tests.rs
- **L90+**: `fields.user` (nonexistent) ‚Üí `fields.username` (see Critical #3)

#### src-tauri/src/connections/manager.rs
- **L398-466** `row_to_connection_config`: Integer truncation risk (see High Priority #8)

#### src-tauri/src/database/arrow_streaming.rs
- **L94, 140, 168, 359**: `blocking_send` inside `spawn_blocking` is correct
- **L326-357**: Cancellation checks between batches only (slow for long-running operators)

---

### üéØ Overall Assessment

**Strong Foundation:**
The Rust backend demonstrates solid engineering with thoughtful security, good separation of concerns, and comprehensive error handling. The architecture is well-suited for a desktop data exploration tool.

**Top Priority Fixes:**
1. ‚úÖ Enforce pool limits for persistent connections (keep permit for connection lifetime)
2. ‚úÖ Honor thread-affinity for DuckDB connections
3. ‚úÖ Fix test compilation errors
4. ‚úÖ Document SQL parameter sanitizer limitations

**Medium Priority:**
- Improve Arrow type coverage or fail clearly on unsupported types
- Fix async lock anti-pattern in cleanup
- Quote secret names defensively
- Use `spawn_blocking` for SQLite persistence

**Known Trade-offs:**
- Sanitizer-based parameter "binding" is pragmatic workaround (DuckDB limitation)
- Cancellation granularity is batch-bound (DuckDB 1.3 lacks interrupt handles)

---

## Part 2: TypeScript Engine Abstraction Layer

**Scope:** 19 TypeScript files (~5k lines) in `src/engines/`

### üî¥ CRITICAL ISSUES (Must Fix Before Merge)

#### 1. Connection Pool Wrapper Breaks Pool Invariants
**File:** `src/engines/connection-pool-with-retry.ts:73-102`

**Issue:**
When `timeoutMs` is provided, `acquire()` returns `new ConnectionWithTimeout(inner)`, but `release()` forwards the wrapper to `pool.release(connection)`. The underlying pool expects the original connection instance to maintain pool invariants.

```typescript
async acquire(): Promise<DatabaseConnection> {
  const connection = await this.withRetry(() => this.pool.acquire());

  if (this.timeoutMs) {
    return new ConnectionWithTimeout(connection, this.timeoutMs); // Wrapper returned
  }
  return connection;
}

async release(connection: DatabaseConnection): Promise<void> {
  await this.pool.release(connection); // Wrapper passed, not original!
}
```

**Impact:**
- Poisons pool's `availableConnections` with wrapper instances not tracked in `connections`
- `removeConnection` will fail to find the actual connection
- Pool accounting broken
- Cleanup routines cannot remove actual connections

**Fix Options:**
1. **Option A:** Add unwrap support to `ConnectionWithTimeout`:
   ```typescript
   const kInner = Symbol('inner');
   wrapper[kInner] = inner;
   // In release: pool.release(connection[kInner] || connection)
   ```

2. **Option B (Preferred):** Don't wrap connection object. Wrap pool operations instead:
   ```typescript
   class TimeoutConnectionPool implements ConnectionPool {
     async acquire(): Promise<DatabaseConnection> {
       const conn = await this.pool.acquire();
       // Return original connection, apply timeout to operations
       return {
         ...conn,
         query: (sql) => withTimeout(() => conn.query(sql), this.timeout)
       };
     }
   }
   ```

---

#### 2. Prepared Statements Ignore Parameters
**File:** `src/engines/tauri-connection.ts:153-220`

**Issue:**
`PreparedStatement.query()` ignores the `params` argument:

```typescript
async prepare(sql: string): Promise<PreparedStatement> {
  await invoke('connection_prepare', { connectionId: this.id, sql });

  return {
    query: async (_params?: any[]) => {
      return this.execute(`EXECUTE ${prepName}`); // params ignored!
    },
    close: async () => { /* ... */ }
  };
}
```

**Impact:**
- Parameters are silently ignored, leading to wrong query results
- Major correctness bug
- API inconsistency with WASM engine

**Fix:**
Use the existing prepared statement infrastructure properly:
```typescript
async prepare(sql: string): Promise<PreparedStatement> {
  const stmtId = await invoke('connection_prepare', {
    connectionId: this.id,
    sql
  });

  return {
    query: async (params?: any[]) => {
      // Use the backend's prepared_statement_execute command
      return invoke('prepared_statement_execute', {
        statementId: stmtId,
        params: params || []
      });
    },
    close: async () => { /* ... */ }
  };
}
```

**Alternative:** Use SQL `EXECUTE prepName(?, ?, ?)` with parameter binding if backend supports it.

---

#### 3. WASM Pool Interval Memory Leak
**File:** `src/engines/duckdb-wasm-connection-pool.ts:50-56`

**Issue:**
`setInterval` for idle cleanup is never cleared:

```typescript
async initialize(db: AsyncDuckDB): Promise<void> {
  this.db = db;

  setInterval(() =>
    this.cleanupIdleConnections(),
    this.config.idleTimeout / 2
  ); // Never cleared!
}
```

**Impact:**
- Memory leak when pool is destroyed
- Background activity continues after `close()`
- Multiple intervals created if `initialize()` called repeatedly

**Fix:**
```typescript
private cleanupIntervalHandle?: NodeJS.Timeout;

async initialize(db: AsyncDuckDB): Promise<void> {
  this.db = db;

  this.cleanupIntervalHandle = setInterval(() =>
    this.cleanupIdleConnections(),
    this.config.idleTimeout / 2
  );
}

async close(): Promise<void> {
  if (this.cleanupIntervalHandle) {
    clearInterval(this.cleanupIntervalHandle);
    this.cleanupIntervalHandle = undefined;
  }
  // ... rest of cleanup
}
```

---

#### 4. Stream API Type Mismatch Between Engines
**Files:**
- `src/engines/duckdb-wasm-connection.ts:32-41`
- `src/engines/duckdb-tauri-engine.ts:86-127`

**Issue:**
Different return types break abstraction:
- **WASM:** `stream()` yields row objects `{col1: value, col2: value}`
- **Tauri:** `stream()` yields Arrow batches/Tables

**Impact:**
- Consumers get different data shapes depending on engine
- Abstraction layer leaks implementation details
- Code using `stream()` must check engine type

**Fix:**
Standardize on Arrow batches/tables for both engines:

```typescript
// In duckdb-wasm-connection.ts
async *stream(sql: string): AsyncGenerator<ArrowTable> {
  const conn = await this.db.connect();
  try {
    const result = await conn.query(sql);
    // Convert to Arrow table instead of yielding rows
    yield result; // Already an Arrow table in WASM
  } finally {
    await conn.close();
  }
}
```

**Alternative:** Document clearly and provide conversion helpers, but standardization is preferred.

---

### ‚ö†Ô∏è HIGH PRIORITY ISSUES (Should Fix)

#### 5. Timeout Wrapper Doesn't Cancel Operations
**File:** `src/engines/connection-with-timeout.ts:31-39`

**Issue:**
When timeout occurs, underlying operation continues running:

```typescript
private async withTimeout<T>(operation: () => Promise<T>, _timeoutMessage: string): Promise<T> {
  const timeoutPromise = new Promise<never>((_, reject) => {
    setTimeout(() =>
      reject(new ConnectionTimeoutError(this.timeoutMs)),
      this.timeoutMs
    );
  });

  return Promise.race([operation(), timeoutPromise]);
  // operation() keeps running even after timeout!
}
```

**Impact:**
- Resource leaks (connections, memory)
- Query continues consuming database resources
- Timer not cleared, causing unhandled rejections
- No true cancellation

**Fix:**
```typescript
private async withTimeout<T>(
  operation: (signal: AbortSignal) => Promise<T>,
  timeoutMessage: string
): Promise<T> {
  const controller = new AbortController();
  let timerId: NodeJS.Timeout | undefined;

  try {
    const timeoutPromise = new Promise<never>((_, reject) => {
      timerId = setTimeout(() => {
        controller.abort(); // Signal cancellation
        reject(new ConnectionTimeoutError(this.timeoutMs));
      }, this.timeoutMs);
    });

    const result = await Promise.race([
      operation(controller.signal),
      timeoutPromise
    ]);

    return result;
  } finally {
    if (timerId) clearTimeout(timerId);
  }
}
```

Then update operations to accept and respect `AbortSignal`.

---

#### 6. Race Condition in Tauri Pool Acquire Lock
**File:** `src/engines/tauri-connection-pool.ts:201-210`

**Issue:**
Flawed lock implementation allows race conditions:

```typescript
async acquire(): Promise<DatabaseConnection> {
  // Multiple threads can pass this await before any sets new lock
  await this.acquireLock;

  // Create a new lock for this acquire operation
  this.acquireLock = new Promise((resolve) => {
    this.acquireLockResolver = resolve;
  });

  // ... lock is released later in finally
}
```

**Impact:**
Multiple concurrent acquires can all pass the first `await` before any creates the new lock, defeating serialization.

**Fix:**
Use a proper queue-based lock or semaphore:

```typescript
class AsyncLock {
  private queue: Array<() => void> = [];
  private locked = false;

  async acquire(): Promise<() => void> {
    if (!this.locked) {
      this.locked = true;
      return () => this.release();
    }

    return new Promise<() => void>((resolve) => {
      this.queue.push(() => {
        resolve(() => this.release());
      });
    });
  }

  private release(): void {
    const next = this.queue.shift();
    if (next) {
      next();
    } else {
      this.locked = false;
    }
  }
}

// Usage:
const unlock = await this.lock.acquire();
try {
  // critical section
} finally {
  unlock();
}
```

---

#### 7. Arrow Batch Acknowledgment Race Condition
**File:** `src/engines/tauri-arrow-reader.ts:158-170`

**Issue:**
Acknowledgment and Set.add() are not atomic:

```typescript
if (this.ackAllOnArrival) {
  if (!this.acknowledgedBatches.has(batchId)) {
    // Between this check and the add below, another handler could run
    invoke('acknowledge_stream_batch', {
      streamId: this.streamId,
      batchIndex: batchId,
    }).catch((err) => { /* ignore */ });

    this.acknowledgedBatches.add(batchId); // Race: could add twice
    ackedNow = true;
  }
}
```

**Impact:**
Under high concurrency, batches could be acknowledged multiple times (though backend should be idempotent).

**Fix:**
```typescript
if (this.ackAllOnArrival && !this.acknowledgedBatches.has(batchId)) {
  // Add to set immediately to claim ownership
  this.acknowledgedBatches.add(batchId);

  invoke('acknowledge_stream_batch', {
    streamId: this.streamId,
    batchIndex: batchId,
  }).catch((err) => {
    // On error, remove from set to allow retry
    this.acknowledgedBatches.delete(batchId);
  });

  ackedNow = true;
}
```

---

#### 8. Engine Cache Doesn't Clean Up Stale Engines
**File:** `src/engines/database-engine-factory.ts:18-23`

**Issue:**
Cached engines not cleaned up when they become stale:

```typescript
static async createEngine(config: EngineConfig): Promise<DatabaseEngine> {
  const cacheKey = this.getCacheKey(config);
  const cached = this.engineCache.get(cacheKey);

  if (cached && cached.isReady()) {
    return cached; // Reuse
  }

  // New engine created but stale one not shut down!
  const engine = /* create new */;
  this.engineCache.set(cacheKey, engine);
  return engine;
}
```

**Impact:**
- Worker/resource leaks from abandoned engines
- Memory grows with failed initialization attempts

**Fix:**
```typescript
if (cached) {
  if (cached.isReady()) {
    return cached;
  }
  // Shutdown stale engine before replacing
  try {
    await cached.shutdown();
  } catch (err) {
    // Log but continue
  }
  this.engineCache.delete(cacheKey);
}
```

---

#### 9. Insufficient Cache Key Includes Wrong Fields
**File:** `src/engines/database-engine-factory.ts:89-96`

**Issue:**
Cache key omits critical configuration:

```typescript
private static getCacheKey(config: EngineConfig): string {
  const { type, storageType, storagePath } = config;
  return `${type}-${storageType}-${storagePath}`;
  // Missing: extensions, options, query timeout, etc.
}
```

**Impact:**
Two configs differing only in extensions/options share the same key and incorrectly reuse an engine with wrong configuration.

**Fix:**
```typescript
private static getCacheKey(config: EngineConfig): string {
  const { type, storageType, storagePath, extensions, options } = config;
  const extHash = this.hashObject(extensions || []);
  const optsHash = this.hashObject(options || {});
  return `${type}-${storageType}-${storagePath}-${extHash}-${optsHash}`;
}

private static hashObject(obj: any): string {
  return createHash('sha256')
    .update(JSON.stringify(obj))
    .digest('hex')
    .slice(0, 8);
}
```

---

### üìã MEDIUM PRIORITY (Improvements)

#### 10. Inconsistent Error Types Across Implementations
**File:** `src/engines/tauri-connection.ts:62-109`

**Issue:**
Tauri connection throws plain `Error` instead of `DatabaseEngineError`:

```typescript
async execute(sql: string, params?: any[]): Promise<QueryResult> {
  try {
    // ...
  } catch (error) {
    throw toError(error); // Returns plain Error, not DatabaseEngineError
  }
}
```

**Impact:**
- `isRecoverableError()` returns false for all Tauri connection errors
- Retry logic doesn't work correctly
- Error classification broken

**Fix:**
```typescript
async execute(sql: string, params?: any[]): Promise<QueryResult> {
  try {
    // ...
  } catch (error) {
    throw parseTauriError(error); // Returns DatabaseEngineError subclass
  }
}
```

---

#### 11. WASM Connection isOpen() Always Returns True
**File:** `src/engines/duckdb-wasm-connection.ts:57-63`

**Issue:**
```typescript
isOpen(): boolean {
  return true; // Always true, even after close()
}
```

**Impact:**
- Pool validation doesn't catch closed connections
- Consumers relying on `isOpen()` get misleading info

**Fix:**
```typescript
private closed = false;

async close(): Promise<void> {
  this.closed = true;
  await this.conn.close();
}

isOpen(): boolean {
  return !this.closed;
}
```

---

#### 12. Performance: Excessive Logging in Production
**Multiple Files**

**Issue:**
Many `console.log` statements in hot paths:
- `src/engines/duckdb-wasm-connection-pool.ts:159-233`
- `src/engines/debug-logger.ts:74`

**Impact:**
- Performance overhead
- Noise in production logs

**Fix:**
```typescript
// Guard with environment check
if (process.env.NODE_ENV === 'development') {
  console.log('...');
}

// Or use debug logger with levels
if (this.debugLogger.isEnabled('debug')) {
  this.debugLogger.debug('...');
}
```

---

#### 13. Type Safety: Missing Type Constraints
**File:** `src/engines/connection-pool-with-retry.ts:45`

**Issue:**
Generic without constraints:
```typescript
async query<T = any>(sql: string): Promise<T> {
  // T could be anything
}
```

**Recommendation:**
```typescript
async query<T extends QueryResult = QueryResult>(sql: string): Promise<T> {
  // T must be QueryResult or subtype
}
```

---

#### 14. Naming Inconsistency: row_count vs rowCount
**File:** `src/engines/types.ts:12`

**Issue:**
Mixed casing in interface:
```typescript
export interface QueryResult {
  rows: any[];
  columns: ColumnInfo[];
  rowCount: number;
  row_count?: number; // Tauri uses snake_case
  queryTime?: number;
}
```

**Recommendation:**
Standardize on camelCase, transform in engine implementations:
```typescript
// In Tauri engine:
return {
  ...result,
  rowCount: result.row_count,
  // Don't include row_count
};
```

---

### ‚úÖ STRENGTHS

1. **Well-Designed Abstraction**
   - Clean interfaces (`DatabaseEngine`, `ConnectionPool`, `DatabaseConnection`)
   - Successfully hides WASM vs native differences
   - Factory pattern for engine creation

2. **Comprehensive Error Handling**
   - Custom error hierarchy (`DatabaseEngineError`, `ConnectionPoolError`, etc.)
   - Recoverability classification
   - Error context preservation
   - `src/engines/errors.ts`

3. **Connection Pooling**
   - Separate pools for WASM and Tauri with appropriate strategies
   - Idle connection cleanup
   - Wait queue for max connections
   - Validation on acquire

4. **Retry/Timeout Infrastructure**
   - Decorator pattern for resilient pools
   - Configurable retry policies
   - Timeout wrapper (despite issues, good concept)

5. **Arrow Streaming Support**
   - `TauriArrowReader` with backpressure (ACKs)
   - Binary IPC for efficient data transfer
   - Proper cleanup and cancellation hooks

6. **Type Safety**
   - Strong TypeScript interfaces
   - Comprehensive test coverage
   - Good separation of concerns

---

### üìä Detailed Line-Level Notes

#### src/engines/connection-pool-with-retry.ts
- **L73-102**: Critical wrapper bug (see #1)
- **L26-41**: Retry logic is good, could optimize logging

#### src/engines/connection-with-timeout.ts
- **L31-39**: Timeout doesn't cancel operations (see #5)
- **L22**: `_timeoutMessage` parameter unused

#### src/engines/database-engine-factory.ts
- **L18-23**: Stale engine cleanup missing (see #8)
- **L89-96**: Cache key insufficient (see #9)

#### src/engines/duckdb-wasm-connection-pool.ts
- **L50-56**: Interval leak (see #3)
- **L73-114**: acquire() logic OK, could validate `isOpen()`
- **L159-233**: sendAbortable good, reduce logging

#### src/engines/duckdb-wasm-connection.ts
- **L57-63**: isOpen() always true (see #11)

#### src/engines/tauri-connection-pool.ts
- **L118-162**: acquire() serialize via lock (see #6)
- **L77-116**: `convertTauriResultToArrowLike` expensive for large results

#### src/engines/tauri-connection.ts
- **L153-220**: Prepared statements ignore params (see #2)
- **L62-109**: Throw plain Error instead of DatabaseEngineError (see #10)

#### src/engines/tauri-arrow-reader.ts
- **L158-170**: Batch ACK race (see #7)
- **L60-106**: Event listeners well-structured
- **L276-318**: getTable() could use timeout

---

### üéØ Overall Assessment

**Strong Abstraction Layer:**
The TypeScript engine abstraction successfully unifies two very different database engines (DuckDB-WASM and native DuckDB via Tauri). The architecture is sound with good patterns (Factory, Decorator, Strategy).

**Top Priority Fixes:**
1. ‚úÖ Fix connection wrapper breaking pool invariants
2. ‚úÖ Implement parameter support in Tauri prepared statements
3. ‚úÖ Clear interval in WASM pool close()
4. ‚úÖ Standardize stream API return types

**Medium Priority:**
- Implement proper timeout cancellation
- Fix Tauri pool acquire lock race condition
- Clean up stale engines in factory cache
- Normalize error types across all implementations

**Performance Optimizations:**
- Guard debug logging
- Consider lazy columnar conversion for large results
- Optimize hot paths

---

---

## Part 3: Frontend Integration & UI Changes

**Scope:** ~185 TypeScript/React files (~14.5k net lines) integrating engine abstraction with UI

### üî¥ CRITICAL ISSUES (Must Fix Before Merge)

#### 1. setState on Unmounted Component
**File:** `src/features/database-context/database-context.tsx:164-254`

**Issue:**
`connectDatabase()` async function updates state after mount, but component may unmount during initialization:

```typescript
const connectDatabase = useCallback(async (): Promise<ConnectionPool | null> => {
  // ... long async initialization ...
  setEngine(engine); // Component might be unmounted!
  setConnectionPool(pool);
  memoizedStatusUpdate({ state: 'ready', message: 'Database ready' });
}, [engineConfig, persistence, memoizedStatusUpdate]);
```

**Impact:**
- React warnings in console
- Potential memory leaks
- Unexpected state updates
- Unpredictable behavior if re-mounted quickly

**Fix:**
```typescript
const connectDatabase = useCallback(async (): Promise<ConnectionPool | null> => {
  const mounted = { current: true }; // Closure-local mount flag

  try {
    // ... initialization ...

    if (!mounted.current) return null;
    setEngine(engine);

    if (!mounted.current) return null;
    setConnectionPool(pool);

    // ... rest of updates with guards
  } catch (err) {
    if (!mounted.current) return null;
    // ... error handling
  }
}, [/* deps */]);

// Add to useEffect cleanup:
useEffect(() => {
  return () => {
    mounted.current = false;
  };
}, []);
```

---

#### 2. Config Object Mutation
**File:** `src/features/database-context/database-context.tsx:136-173`

**Issue:**
Mutating `engineConfig` prop directly:

```typescript
const config = engineConfig ?? detectOptimalEngine();

if (config.storageType === 'persistent') {
  if (config.type === 'duckdb-wasm') {
    config.storagePath = dbPath; // Mutating prop or shared object!
  }
}
```

**Impact:**
- Unexpected side effects for callers reusing config
- Hard-to-debug state pollution
- Violates React principles

**Fix:**
```typescript
const baseConfig = engineConfig ?? detectOptimalEngine();
const config = { ...baseConfig }; // Clone first

if (config.storageType === 'persistent') {
  if (config.type === 'duckdb-wasm') {
    config = { ...config, storagePath: dbPath }; // Immutable update
  }
}
```

---

#### 3. In-Flight Promise Never Cleared
**File:** `src/features/database-context/database-context.tsx:200-210`

**Issue:**
`inFlight.current` only reset in catch(), not in success path:

```typescript
const connectDatabase = useCallback(async (): Promise<ConnectionPool | null> => {
  if (inFlight.current) {
    return inFlight.current; // Reuse in-flight request
  }

  inFlight.current = (async () => {
    // ... initialization ...
    return pool;
  })();

  try {
    return await inFlight.current;
  } catch (err) {
    inFlight.current = null; // Only cleared on error!
    throw err;
  }
}, [/* deps */]);
```

**Impact:**
- Subsequent calls always return the same resolved promise
- Re-initialization impossible even if engine config changes
- Cached connection pool used even after shutdown

**Fix:**
```typescript
try {
  return await inFlight.current;
} catch (err) {
  throw err;
} finally {
  inFlight.current = null; // Always clear
}
```

---

#### 4. Zustand Store Direct Mutation
**File:** `src/services/extension-loader.ts:164-169`

**Issue:**
Mutating Zustand state directly instead of using setter:

```typescript
const store = useExtensionManagementStore.getState();
store.extensions = store.extensions.map((ext) =>
  ext.name === extensionName ? { ...ext, status: 'loaded' } : ext
); // Direct mutation - Zustand won't track!
```

**Impact:**
- UI doesn't re-render
- State persistence broken
- Stale data in components

**Fix:**
```typescript
useExtensionManagementStore.setState((state) => ({
  extensions: state.extensions.map((ext) =>
    ext.name === extensionName ? { ...ext, status: 'loaded' } : ext
  )
}));
```

---

#### 5. Race Condition in Connection Initialization
**File:** `src/features/database-context/database-context.tsx:200-210`

**Issue:**
Check-and-set pattern for `inFlight.current` is not atomic:

```typescript
if (inFlight.current) {
  return inFlight.current; // Thread 1 checks - null
}
// Thread 2 checks - still null
inFlight.current = (async () => { /* ... */ })(); // Both set!
```

**Impact:**
- Multiple concurrent database initializations
- Connection pool conflicts
- Resource exhaustion

**Fix:**
```typescript
// Option A: Use ref + Promise for single-flight coordination
const connectDatabase = useCallback(async (): Promise<ConnectionPool | null> => {
  if (inFlight.current) {
    try {
      return await inFlight.current;
    } catch {
      // If failed, allow retry
    }
  }

  const promise = (async () => {
    // ... actual initialization ...
  })();

  inFlight.current = promise;

  try {
    const result = await promise;
    return result;
  } finally {
    // Clear after completion to allow re-init
    if (inFlight.current === promise) {
      inFlight.current = null;
    }
  }
}, [/* deps */]);
```

---

### ‚ö†Ô∏è HIGH PRIORITY ISSUES (Should Fix)

#### 6. Unhandled Promise Rejection in queryWithTimeout
**File:** `src/services/extension-loader.ts:41-55`

**Issue:**
Timer not cleared, causing unhandled rejections:

```typescript
static async queryWithTimeout(exec: Promise<any>, timeout: number): Promise<any> {
  return Promise.race([
    exec,
    new Promise((_, reject) =>
      setTimeout(() => reject(new Error(`Query timeout: ${timeout}ms`)), timeout)
    ),
  ]);
  // If exec resolves, setTimeout still fires and rejects!
}
```

**Impact:**
- Unhandled promise rejections logged
- Timer leaks
- Potential memory issues

**Fix:**
```typescript
static async queryWithTimeout(exec: Promise<any>, timeout: number): Promise<any> {
  let timerId: NodeJS.Timeout | undefined;

  try {
    const timeoutPromise = new Promise((_, reject) => {
      timerId = setTimeout(() =>
        reject(new Error(`Query timeout: ${timeout}ms`)),
        timeout
      );
    });

    const result = await Promise.race([exec, timeoutPromise]);
    return result;
  } finally {
    if (timerId) clearTimeout(timerId);
  }
}
```

---

#### 7. Browser Input File Picker Doesn't Handle Cancellation
**File:** `src/services/file-picker/web-file-picker.ts:250-309`

**Issue:**
`input.oncancel` not supported in all browsers, promise can hang forever:

```typescript
return new Promise((resolve, reject) => {
  input.onchange = () => { /* ... resolve */ };
  input.oncancel = () => resolve([]); // Not portable!
  document.body.appendChild(input);
  input.click();
});
```

**Impact:**
- Promise never resolves on cancel in some browsers
- Memory leak (dangling promise + DOM element)
- UI appears frozen

**Fix:**
```typescript
return new Promise((resolve, reject) => {
  const cleanup = () => {
    window.removeEventListener('focus', onFocus);
    document.body.removeChild(input);
  };

  const onFocus = () => {
    setTimeout(() => {
      if (!input.files || input.files.length === 0) {
        cleanup();
        resolve([]); // Cancelled
      }
    }, 300);
  };

  input.onchange = () => {
    cleanup();
    resolve(Array.from(input.files || []));
  };

  window.addEventListener('focus', onFocus);
  document.body.appendChild(input);
  input.click();
});
```

---

#### 8. Platform Checks in Service Methods
**File:** `src/services/browser-credential-store.ts:18-25`, `src/services/extension-loader.ts:45-55`

**Issue:**
Runtime platform detection instead of factory pattern:

```typescript
static async save(connectionId: string, credentials: any): Promise<void> {
  if (isTauriEnvironment()) {
    throw new Error('Use backend credential storage in Tauri environment');
  }
  // ... browser-specific code
}
```

**Impact:**
- Unnecessary code loaded in bundles
- Runtime errors instead of type errors
- Harder to test
- Violates single responsibility

**Fix:**
Create platform-specific service implementations:

```typescript
// src/services/credential-store/index.ts
import { isTauriEnvironment } from '@utils/browser';

let credentialStore: CredentialStore;

export function getCredentialStore(): CredentialStore {
  if (!credentialStore) {
    credentialStore = isTauriEnvironment()
      ? new TauriCredentialStore()
      : new BrowserCredentialStore();
  }
  return credentialStore;
}

// Usage:
const store = getCredentialStore();
await store.save(connectionId, credentials);
```

---

#### 9. Sequential State Updates Cause Intermediate Renders
**File:** `src/store/persistence-init.ts:150-160`

**Issue:**
Multiple `setState` calls in sequence:

```typescript
useAppStore.setState({
  localEntries,
  sqlScripts,
  tabs,
  // ...
});

// Later...
useAppStore.setState({
  dataSources: enrichedDataSources,
});
```

**Impact:**
- Unnecessary re-renders
- Inconsistent state during intermediate renders
- Performance degradation

**Fix:**
```typescript
useAppStore.setState({
  localEntries,
  sqlScripts,
  tabs,
  activeTabId,
  previewTabId,
  tabOrder,
  dataSources: enrichedDataSources, // Batch all updates
});
```

---

#### 10. Engine Cleanup Only on Unmount
**File:** `src/features/database-context/database-context.tsx:65-70`

**Issue:**
Effect cleanup only runs on unmount, not on engine change:

```typescript
useEffect(
  () => () => {
    if (engine) {
      engine.shutdown(); // Only runs on unmount
    }
  },
  [engine], // Runs effect on engine change, but cleanup only on unmount!
);
```

**Impact:**
- Previous engines not shut down when engine changes
- Worker/resource leaks
- Memory growth

**Fix:**
```typescript
useEffect(() => {
  // Effect runs on mount and engine change
  return () => {
    // Cleanup runs on unmount AND before next engine
    if (engine) {
      engine.shutdown();
    }
  };
}, [engine]);
```

---

### üìã MEDIUM PRIORITY (Improvements)

#### 11. SQL Injection in Attachment Loader
**File:** `src/services/attachment-loader.ts:14-61`

**Issue:**
Direct string interpolation of credentials into SQL:

```typescript
private static buildSecretSql(db: any, credentials: any): string {
  return `
    CREATE TEMPORARY SECRET ${secretName} (
      TOKEN '${credentials.token}' -- No escaping!
    )
  `;
}
```

**Recommendation:**
Use proper escaping:
```typescript
private static escapeString(str: string): string {
  return str.replace(/'/g, "''");
}

return `TOKEN '${this.escapeString(credentials.token)}'`;
```

---

#### 12. Missing Environment Guards on Tauri APIs
**Files:** `src/services/secrets-api.ts`, `src/services/connections-api.ts`

**Issue:**
No guards against accidental web invocation:

```typescript
export const SecretsAPI = {
  async listSecrets(): Promise<SecretMetadata[]> {
    return invoke('list_secrets'); // Undefined in browser!
  }
};
```

**Recommendation:**
```typescript
export const SecretsAPI = {
  async listSecrets(): Promise<SecretMetadata[]> {
    if (!isTauriEnvironment()) {
      throw new Error('SecretsAPI only available in desktop app');
    }
    return invoke('list_secrets');
  }
};
```

---

#### 13. Throwing Errors in Hooks During Render
**File:** `src/features/database-context/database-context.tsx:40-50`

**Issue:**
```typescript
export const useInitializedDatabaseConnectionPool = (): ConnectionPool => {
  const pool = useContext(DatabaseConnPoolContext);

  if (!pool) {
    throw new Error('...'); // Unrecoverable crash!
  }

  return pool;
}
```

**Recommendation:**
Return error state or use error boundary:
```typescript
export const useInitializedDatabaseConnectionPool = (): {
  pool: ConnectionPool | null;
  error: string | null;
} => {
  const pool = useContext(DatabaseConnPoolContext);

  if (!pool) {
    return { pool: null, error: 'Database not initialized' };
  }

  return { pool, error: null };
};
```

---

#### 14. Platform Capabilities Mismatch
**File:** `src/utils/platform-capabilities.ts:52-56`

**Issue:**
Browser path includes unsupported extensions:

```typescript
supportedExtensions: ['httpfs', 'postgres_scanner'], // postgres_scanner not in WASM!
```

**Fix:**
```typescript
supportedExtensions: isTauriEnvironment()
  ? ['httpfs', 'postgres_scanner', 'mysql_scanner']
  : ['httpfs'], // Only WASM-compatible
```

---

### ‚úÖ STRENGTHS

1. **Service Layer Abstraction**
   - File picker with web/Tauri implementations
   - Credential storage abstraction
   - Extension loader with auto-detection

2. **Persistence Migration**
   - SQLite adapter for Tauri
   - IndexedDB adapter for web
   - Graceful data restoration

3. **React Context Architecture**
   - Proper separation of concerns
   - Status tracking for initialization
   - Multiple context providers for different concerns

4. **Type Safety**
   - Strong TypeScript usage
   - Proper interfaces for models
   - Good use of generics

---

### üéØ Overall Assessment

**Solid Integration with Issues:**
The frontend successfully integrates the new engine abstraction, but contains several critical React anti-patterns and race conditions that must be fixed before production.

**Top Priority Fixes:**
1. ‚úÖ Add mounted ref guards to prevent setState on unmounted
2. ‚úÖ Fix config mutation - clone before modifying
3. ‚úÖ Clear inFlight promise in finally
4. ‚úÖ Use Zustand setState instead of direct mutation
5. ‚úÖ Fix race condition in connection initialization

**Medium Priority:**
- Implement queryWithTimeout properly with timer cleanup
- Fix file picker cancellation handling
- Replace runtime platform checks with factory pattern
- Batch state updates
- Fix engine cleanup lifecycle

---

---

## Part 4: Tests & Documentation

**Scope:** Test files and comprehensive documentation

### ‚úÖ STRENGTHS

1. **Comprehensive Documentation**
   - **PONDPILOT_ARCHITECTURE.md** (742 lines): Excellent overview of architecture decisions
   - **TAURI_UNIFIED_STREAMING_ARCHITECTURE.md** (470 lines): Detailed streaming design
   - **secrets-management-design.md** (1015 lines): Thorough security documentation
   - **TAURI_PERSISTENCE_DESIGN.md** (197 lines): Clear persistence strategy
   - **MIGRATION_GUIDE.md**: File handle abstraction migration guide

2. **Test Coverage**
   - Engine abstraction tests: `src/engines/__tests__/`
   - Integration tests for multi-engine support
   - Secrets management tests
   - Data source migration tests

3. **Operational Guides**
   - macOS signing and notarization process
   - Graceful startup handling
   - Logging policy

### ‚ö†Ô∏è ISSUES FOUND

#### 1. Missing Test Coverage Areas
- **Connection pool edge cases**: No tests for pool exhaustion, permit lifetime bugs
- **Race condition scenarios**: No concurrent connection acquisition tests
- **Tauri prepared statement parameters**: No tests verifying parameters are passed correctly
- **WASM pool interval cleanup**: No test for memory leak on close()

#### 2. Documentation Gaps
- **Migration path**: No guide for migrating from old DuckDB context to new database context
- **Platform capabilities**: No documentation of feature parity between WASM and Tauri
- **Error handling**: No guide for handling platform-specific errors
- **Performance benchmarks**: No comparison of WASM vs Tauri performance

### üìã RECOMMENDATIONS

1. **Add Critical Tests**
   ```typescript
   // tests/integration/engines/connection-pool.spec.ts
   describe('Connection Pool', () => {
     it('should enforce pool limits for persistent connections', async () => {
       // Test for Rust bug #1
     });

     it('should handle concurrent acquire requests safely', async () => {
       // Test for TypeScript bug #6
     });

     it('should clean up interval timers on pool close', async () => {
       // Test for TypeScript bug #3
     });
   });
   ```

2. **Add Migration Guide**
   ```markdown
   # docs/MIGRATION_TO_DATABASE_CONTEXT.md

   ## Migrating from DuckDB Context to Database Context

   ### Old Pattern
   ```typescript
   const { db } = useDuckDBContext();
   ```

   ### New Pattern
   ```typescript
   const pool = useInitializedDatabaseConnectionPool();
   const conn = await pool.acquire();
   try {
     await conn.query(sql);
   } finally {
     await pool.release(conn);
   }
   ```
   ```

3. **Document Platform Differences**
   ```markdown
   # docs/PLATFORM_FEATURE_PARITY.md

   | Feature | WASM | Tauri | Notes |
   |---------|------|-------|-------|
   | Connection Pooling | ‚úÖ | ‚úÖ | Different implementations |
   | Prepared Statements | ‚úÖ | ‚ö†Ô∏è | Tauri ignores params (bug #2) |
   | Extensions | httpfs only | All | WASM limited |
   | Secrets Management | Browser localStorage | OS Keychain | Different security |
   ```

---

### üéØ Overall Assessment

**Excellent Documentation:**
The PR includes comprehensive technical documentation explaining architecture decisions, security design, and operational procedures. This is a strength.

**Test Coverage Gaps:**
While basic tests exist, critical bugs found in review (connection pool permits, prepared statements, race conditions) are not tested. Add regression tests for all critical bugs before merge.

---

## Summary of All Parts

### Critical Issues by Severity

**üî¥ Blocking (Must Fix):**
- **Part 1 (Rust)**: 4 critical issues
  - Connection pool permit lifetime bug
  - Thread-affinity violation
  - Test compilation failures
  - SQL parameter binding vulnerability

- **Part 2 (TypeScript Engines)**: 4 critical issues
  - Connection wrapper breaks pool invariants
  - Prepared statements ignore parameters
  - WASM pool interval memory leak
  - Stream API type mismatch

- **Part 3 (Frontend)**: 5 critical issues
  - setState on unmounted component
  - Config object mutation
  - In-flight promise never cleared
  - Zustand store direct mutation
  - Race condition in connection init

**Total Critical: 13 issues**

---

**‚ö†Ô∏è High Priority:**
- Part 1: 4 issues (async lock anti-pattern, unquoted secrets, Arrow conversion, int truncation)
- Part 2: 5 issues (timeout cancellation, acquire lock race, ACK race, stale engines, cache key)
- Part 3: 5 issues (promise rejection, file picker, platform checks, state batching, engine cleanup)

**Total High Priority: 14 issues**

---

**üìã Medium Priority:**
- Part 1: 6 issues
- Part 2: 5 issues
- Part 3: 4 issues

**Total Medium Priority: 15 issues**

---

## Action Plan

### Phase 1: Critical Fixes (Blocking Merge)

**Week 1 - Rust Backend (Sasha + Team)**
1. Fix connection pool permit lifetime (Part 1, Issue #1) - **2-3 days**
   - Move permit into dedicated thread
   - Store with ConnectionHandler
   - Add RAII guard

2. Fix thread-affinity violation (Part 1, Issue #2) - **1 day**
   - Call `create_connection()` in correct thread

3. Fix test compilation (Part 1, Issue #3) - **1 hour**
   - Update field names in tests

4. Document SQL sanitizer (Part 1, Issue #4) - **2 hours**
   - Add limitation docs
   - Add security warnings

**Week 2 - TypeScript Engines (Sasha + Team)**
5. Fix connection wrapper (Part 2, Issue #1) - **1-2 days**
   - Implement unwrap support OR
   - Wrap operations instead of connection

6. Fix prepared statements (Part 2, Issue #2) - **1 day**
   - Use `prepared_statement_execute` command
   - Pass parameters correctly

7. Fix WASM interval leak (Part 2, Issue #3) - **2 hours**
   - Store interval handle
   - Clear in close()

8. Standardize stream API (Part 2, Issue #4) - **1 day**
   - Choose Arrow batches for both engines
   - Update WASM to yield Arrow

**Week 3 - Frontend Integration (Sasha + Team)**
9. Add mounted ref guards (Part 3, Issue #1) - **1 day**
   - Prevent setState on unmounted
   - Add to all async callbacks

10. Fix config mutation (Part 3, Issue #2) - **2 hours**
    - Clone before modifying

11. Fix inFlight clearing (Part 3, Issue #3) - **1 hour**
    - Use finally block

12. Fix Zustand mutations (Part 3, Issue #4) - **2 hours**
    - Use setState everywhere

13. Fix race condition (Part 3, Issue #5) - **1 day**
    - Implement proper single-flight pattern

---

### Phase 2: High Priority (Before Production)

**Week 4 - Cleanup & Polish**
- Fix all high priority issues (14 total)
- Add regression tests for all critical bugs
- Performance testing WASM vs Tauri
- Security audit of SQL injection points

---

### Phase 3: Medium Priority (Post-Launch)

**Ongoing**
- Address medium priority issues incrementally
- Monitor production for edge cases
- Gather user feedback
- Optimize based on real-world usage

---

### Testing Strategy

**Before Merge:**
1. Unit tests for all critical bug fixes
2. Integration tests for multi-engine scenarios
3. E2E tests for platform detection
4. Load tests for connection pools
5. Security tests for SQL injection

**Before Production:**
1. Manual testing on macOS (Tauri)
2. Manual testing on Windows (Tauri)
3. Manual testing on Web (WASM)
4. Performance benchmarks
5. Security audit

---

### Risk Mitigation

**High Risk Areas:**
1. Connection pool management (multiple critical bugs)
2. React lifecycle (setState on unmounted)
3. SQL injection (sanitizer limitations)
4. Race conditions (multiple concurrent access points)

**Mitigation:**
- Add comprehensive logging
- Implement circuit breakers
- Add error boundaries
- Monitor production metrics
- Feature flags for gradual rollout

---

### Success Criteria

**Merge Criteria:**
- [ ] All 13 critical issues fixed
- [ ] Regression tests added for critical bugs
- [ ] Documentation updated
- [ ] Code review approved
- [ ] CI/CD passing

**Production Criteria:**
- [ ] All high priority issues fixed
- [ ] Performance benchmarks acceptable
- [ ] Security audit passed
- [ ] Beta testing completed
- [ ] Rollback plan in place

---

## Final Recommendation

**DO NOT MERGE** until all 13 critical issues are resolved. The architecture is sound and well-documented, but the implementation has several correctness and safety bugs that must be fixed first.

**Estimated Timeline:**
- Critical fixes: 3 weeks
- High priority: 1 week
- Testing & validation: 1 week
- **Total: 5 weeks to production-ready**

**Strengths to Preserve:**
- Excellent architecture and documentation
- Good separation of concerns
- Strong type safety
- Comprehensive error handling framework

The oxidize branch represents a significant architectural improvement, but requires focused debugging effort before merge.
